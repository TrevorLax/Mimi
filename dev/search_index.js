var documenterSearchIndex = {"docs":
[{"location":"howto/howto_7/#How-to-Guide-7:-Port-to-Mimi-v0.5.0-1","page":"7 Port to v0.5.0","title":"How-to Guide 7: Port to Mimi v0.5.0","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"The release of Mimi v0.5.0 is a breaking release, necessitating the adaptation of existing models' syntax and structure in order for those models to run on this new version.  This guide provides an overview of the steps required to get most models using the v0.4.0 API working with v0.5.0.  It is not a comprehensive review of all changes and new functionalities, but a guide to the minimum steps required to port old models between versions.  For complete information on the new version and its functionalities, see the full documentation.","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"This guide is organized into six main sections, each describing an independent set of changes that can be undertaken in any order desired.  ","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"Defining components\nConstructing a model\nRunning the model\nAccessing results\nPlotting\nAdvanced topics","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"A Note on Function Naming: There has been a general overhaul on function names, especially those in the explicitly user-facing API, to be consistent with Julia conventions and the conventions of this Package.  These can be briefly summarized as follows:","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"use _ for readability\nappend all functions with side-effects, i.e., non-pure functions that return a value but leave all else unchanged with a !\nthe commonly used terms component, variable, and parameter are shortened to comp, var, and param\nfunctions that act upon a component, variable, or parameter are often written in the form [action]_[comp/var/param]","category":"page"},{"location":"howto/howto_7/#Defining-Components-1","page":"7 Port to v0.5.0","title":"Defining Components","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"The run_timestep function is now contained by the @defcomp macro, and takes the parameters p, v, d, t, referring to Parameters, Variables, and Dimensions of the component you defined.  The fourth argument is an AbstractTimestep, i.e., either a FixedTimestep or a VariableTimestep.  Similarly, the optional init function is also contained by @defcomp, and takes the parameters p, v, d.  Thus, as described in the user guide, defining a single component is now done as follows:","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"In this version, the fourth argument (t below) can no longer always be used simply as an Int. Indexing with t is still permitted, but special care must be taken when comparing t with conditionals or using it in arithmetic expressions.  The full API as described later in this document in Advanced Topics:  Timesteps and available functions.  Since differential equations are commonly used as the basis for these models' equations, the most commonly needed change will be changing if t == 1 to if is_first(t)","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"@defcomp component1 begin\n\n    # First define the state this component will hold\n    savingsrate = Parameter()\n\n    # Second, define the (optional) init function for the component\n    function init(p, v, d)\n    end\n\n    # Third, define the run_timestep function for the component\n    function run_timestep(p, v, d, t)\n    end\n\nend","category":"page"},{"location":"howto/howto_7/#Constructing-a-Model-1","page":"7 Port to v0.5.0","title":"Constructing a Model","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"In an effort to standardize the function naming protocol within Mimi, and to streamline it with the Julia convention, several function names have been changed.  The table below lists a subset of these changes, focused on the exported API functions most commonly used in model construction.  ","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"Old Syntax New Syntax\naddcomponent! add_comp!\nconnectparameter connect_param!\nsetleftoverparameters set_leftover_params!\nsetparameter set_param!\nadddimension add_dimension!\nsetindex set_dimension!","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"Changes to various optional keyword arguments:","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"add_comp!:  Through Mimi v0.9.4, the optional keyword arguments first and last could be used to specify times for components that do not run for the full length of the model, like this: add_comp!(mymodel, ComponentC; first=2010, last=2100). This functionality is currently disabled, and all components must run for the full length of the model's time dimension. This functionality may be re-implemented in a later version of Mimi.","category":"page"},{"location":"howto/howto_7/#Running-a-Model-1","page":"7 Port to v0.5.0","title":"Running a Model","text":"","category":"section"},{"location":"howto/howto_7/#Accessing-Results-1","page":"7 Port to v0.5.0","title":"Accessing Results","text":"","category":"section"},{"location":"howto/howto_7/#Plotting-and-the-Explorer-UI-1","page":"7 Port to v0.5.0","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"This release of Mimi does not include the plotting functionality previously offered by Mimi.  While the previous files are still included, the functions are not exported as efforts are made to simplify and improve the plotting associated with Mimi.  ","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"The new version does, however, include a new UI tool that can be used to visualize model results.  This explore function is described in the User Guide under Advanced Topics.","category":"page"},{"location":"howto/howto_7/#Advanced-Topics-1","page":"7 Port to v0.5.0","title":"Advanced Topics","text":"","category":"section"},{"location":"howto/howto_7/#Timesteps-and-available-functions-1","page":"7 Port to v0.5.0","title":"Timesteps and available functions","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"As previously mentioned, some relevant function names have changed.  These changes were made to eliminate ambiguity.  For example, the new naming clarifies that is_last returns whether the timestep is on the last valid period to be run, not whether it has run through that period already.  This check can still be achieved with is_finished, which retains its name and function.  Below is a subset of such changes related to timesteps and available functions.","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"Old Syntax New Syntax\nisstart is_first\nisstop is_last","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"As mentioned in earlier in this document, the fourth argument in run_timestep is an AbstractTimestep i.e. a FixedTimestep or a VariableTimestep and is a type defined within Mimi in \"src/time.jl\".  In this version, the fourth argument (t below) can no longer always be used simply as an Int. Defining the AbstractTimestep object as t, indexing with t is still permitted, but special care must be taken when comparing t with conditionals or using it in arithmatic expressions.  Since differential equations are commonly used as the basis for these models' equations, the most commonly needed change will be changing if t == 1 to if is_first(t).","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"The full API:","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"you may index into a variable or parameter with [t] or [t +/- x] as usual\nto access the time value of t (currently a year) as a Number, use gettime(t)\nuseful functions for commonly used conditionals are is_first(t) and is_last(t)\nto access the index value of t as a Number representing the position in the time array, use t.t.  Users are encouraged to avoid this access, and instead use the options listed above or a separate counter variable. each time the function gets called.  ","category":"page"},{"location":"howto/howto_7/#Parameter-connections-between-different-length-components-1","page":"7 Port to v0.5.0","title":"Parameter connections between different length components","text":"","category":"section"},{"location":"howto/howto_7/#More-on-parameter-indices-1","page":"7 Port to v0.5.0","title":"More on parameter indices","text":"","category":"section"},{"location":"howto/howto_7/#Updating-an-external-parameter-1","page":"7 Port to v0.5.0","title":"Updating an external parameter","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"To update an external parameter, use the functions update_param! and update_params! (previously known as update_external_parameter and update_external_parameters, respectively.)  Their calling signatures are:","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"update_params!(md::ModelDef, parameters::Dict; update_timesteps = false)\nupdate_param!(md::ModelDef, name::Symbol, value; update_timesteps = false)","category":"page"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"For external parameters with a :time dimension, passing update_timesteps=true indicates that the time keys (i.e., year labels) should also be updated in addition to updating the parameter values.","category":"page"},{"location":"howto/howto_7/#Setting-parameters-with-a-dictionary-1","page":"7 Port to v0.5.0","title":"Setting parameters with a dictionary","text":"","category":"section"},{"location":"howto/howto_7/#","page":"7 Port to v0.5.0","title":"7 Port to v0.5.0","text":"The function set_leftover_params! replaces the function setleftoverparameters.","category":"page"},{"location":"howto/howto_3/#How-to-Guide-3:-Conduct-Monte-Carlo-Simulations-and-Sensitivity-Analysis-1","page":"3 Monte Carlo + SA","title":"How-to Guide 3: Conduct Monte Carlo Simulations and Sensitivity Analysis","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Mimi includes a host of routines which support running Monte Carlo simulations and various sensitivity analysis methods on Mimi models. Tutorial 5: Monte Carlo Simulations and Sensitivity Analysis Support is a good starting point for learning about these methods.  This how-to guide includes more detail and optionality, covering more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in the tutorial.","category":"page"},{"location":"howto/howto_3/#Overview-1","page":"3 Monte Carlo + SA","title":"Overview","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Running Monte Carlo simulations, and proximal sensitivity analysis, in Mimi can be broken down into three primary user-facing elements:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The @defsim macro, which defines random variables (RVs) which are assigned distributions and associated with model parameters, and override the default (random) sampling method.\nThe run function, which runs a simulation instance, setting the model(s) on which a simulation definition can be run within that, generates all trial data with generate_trials!, and has several with optional parameters and optional callback functions to customize simulation behavior. \nThe analyze function, which takes a simulation instance, analyzes the results and returns results specific to the type of simulation passed in. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The rest of this document will be organized as follows:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The @defsim macro\nThe run function\nThe analyze function\nPlotting and the Explorer UI\nOther Useful Functions\nExamples","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"We will refer separately to two types, SimulationDef and SimulationInstance.  They are referred to as sim_def and sim_inst respectively as function arguments, and sd and si respectively as local variables.","category":"page"},{"location":"howto/howto_3/#.-The-@defsim-macro-1","page":"3 Monte Carlo + SA","title":"1. The @defsim macro","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The first step in a Mimi sensitivity analysis is using the @defsim macro to define and return a SimulationDef{T}. This simulation definition contains all the definition information in a form that can be applied at run-time. The T in SimulationDef{T} is any type that your application would like to live inside the SimulationDef struct, and most importantly specifies the sampling strategy to be used in your sensitivity analysis.  ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"We have implemented four types for T <: AbstractSimulationData:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Simple random-sampling Monte Carlo Simulation (MCSData),\nLatin Hypercube Sampling (LHSData)\nSobol sampling and analysis (SobolData)\nDelta sampling and analysis (DeltaData) - Beta, we don't recommend use yet","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"We also define type constants with friendlier names for these parameterized types:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"const MonteCarloSimulationDef = SimulationDef{MCSData}\nconst MonteCarloSimulationInstance = SimulationInstance{MCSData}\n\nconst LatinHypercubeSimulationDef = SimulationDef{LHSData}\nconst LatinHypercubeSimulationInstance = SimulationInstance{LHSData}\n\nconst SobolSimulationDef = SimulationDef{SobolData}\nconst SobolSimulationInstance = SimulationInstance{SobolData}\n\nconst DeltaSimulationDef = SimulationDef{DeltaData}\nconst DeltaSimulationInstance = SimulationInstance{DeltaData}","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In order to build the information required at run-time, the @defsim macro carries out several tasks including the following.","category":"page"},{"location":"howto/howto_3/#Define-Random-Variables-(RVs)-1","page":"3 Monte Carlo + SA","title":"Define Random Variables (RVs)","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The macro must define random variables (RVs) by assigning names to distributions, which can be any object that supports the following function:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"rand(dist, count::Int=1) which produces a single value when count == 1, else a Vector of values.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"If using Latin Hypercube Sampling (LHS) is used, the following function must also be defined:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"quantile(dist, quantiles::Vector{Float64}) which returns values for the given quantiles of the distribution.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In addition to the distributions available in the Distributions package, Mimi provides the following options.  Note that these are not exported by default, so they need to either be explicitly imported (ie. import Mimi: EmpiricalDistribution) or prefixed with Mimi. when implemented (ie. Mimi.EmpiricalDistribution(vals, probs)):","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"EmpiricalDistribution, which takes a vector of values and (optional) vector of probabilities and produces samples from these values using the given probabilities, if provided, or equal probability otherwise. To use this in a @defsim, you might do:\nusing CSVFiles\nusing DataFrames\nusing Mimi\nimport Mimi: EmpiricalDistribution # not currently exported so you just need to grab it\n\n# read in your values\nvalues = load(\"path_to_values_file\"; header_exists = false) |> DataFrame\n# read in your probabilities (optional, if none are provided we assume all equal)\n# note that the probabilities need to be Float type and should roughly add to 1\nprobs = load(\"path_to_probabilities_file\"; header_exists = false) |> DataFrame\n\n# create your simulation\n@defsim  begin\n    ...\n    RandomVariable1 = EmpiricalDistribution(values, probs)\n    ...\nend\nNote there are many ways to load values, we use DataFrames and CSVFiles above but there might be an easier way depending on what packages you like\nSampleStore{T}, which stores a vector of samples that are produced in order by the rand function. This allows the user to to store a predefined set of values (useful for regression testing) and it is used by the LHS method, which draws all required samples at once at equal probability intervals and then shuffles the values. It is also used when rank correlations are specified, since this requires re-ordering draws from random variables.\nReshapedDistribution, which supports use of vector-valued distributions, i.e., those that generate   vectors of values for each single draw. An example (that motivated this addition) is the Dirichlet distribution, which produces a vector of values that sum to 1. To use this in @defsim, you might do:\n  rd = ReshapedDistribution([5, 5], Dirichlet(25,1))\nThis code creates a pseudo-distribution that, for each draw, produces a 5x5 matrix of values that sum to 1.","category":"page"},{"location":"howto/howto_3/#Apply-RVs-to-model-parameters-1","page":"3 Monte Carlo + SA","title":"Apply RVs to model parameters","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"For all applications in this section, it is important to note that for each trial, a random variable on the right hand side of an assignment  will take on the value of a single draw from the given distribution.  This means that even if the random variable is applied to more than one parameter on the left hand side (such as assigning to a slice), each of these parameters will be assigned the same value, not different draws from the distribution.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The macro next defines how to apply the values generated by each RV to model parameters based on a pseudo-assignment operator. The left hand side of these assignments can be either a param, which must refer to a shared model parameter, or comp.param which refers to an unshared model parameter specific to a component.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"param = RV or comp.param = RV replaces the values in the parameter with the value of the RV for the current trial.\nparam += RV or comp.param += RV replaces the values in the parameter with the sum of the original value and the value of the RV for the current trial.\nparam *= RV or comp.param *= RV replaces the values in the parameter with the product of the original value and the value of the RV for the current trial.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"As described below, in @defsim, you can apply distributions to specific slices of array parameters, and you can \"bulk assign\" distributions to elements of a vector or matrix using a more condensed syntax. Note that these relationship assignments are referred to as transforms, and are referred to later in this documentation in the add_transform! and delete_transform! helper functions.","category":"page"},{"location":"howto/howto_3/#Apply-RVs-to-model-parameters:-Assigning-to-array-slices-1","page":"3 Monte Carlo + SA","title":"Apply RVs to model parameters: Assigning to array slices","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Options for applying distributions to array slices is accomplished using array access syntax on the left-hand side of an assignment. The assignment may use any of these assignment operators: =, *=, or +=, as described above. Slices can be indicated using a variety of specifications. Assume we define two parameters in @defcomp as","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"  foo = Parameter(index=[regions])\n  bar = Parameter(index=[time, regions])","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"with regions defined as [:USA, :CAN, :MEX, :ROW]","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"We can assign distributions to the elements of foo several ways:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Using a symbol or string or tuple of symbols or strings. Note that values specified without a \":\" prefix or double quotes are treated as symbols. To specify strings, quote them the usual way.\nfoo[USA] = Uniform(0, 1) would assign the RV to foo[:USA] only.\nfoo[(USA, CAN, MEX)] = Uniform(0, 1) would assign the same RV to 3 elements of foo.  That is, a single value is drawn from the RV with distribution Uniform(0, 1) and this value is assigned to all three elements of foo.\nA :, indicating all elements for this dimension\nfoo[:] = Normal(10.0 3.0) would use a draw from the Normal RV for all elements of foo.\nA : range, with or without a step, or a tuple of integers\nbar[2050:10:2080, :] = Uniform(2, 3) would assign a single Uniform RV to all regions for  time steps with labels 2050, 2060, 2070, and 2080.\nbar[(2050, 2060, 2070, 2080), :] = Uniform(2, 3) does the same thing using a tuple of values.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"If regions were defined using strings, as in [\"USA\", \"CAN\", \"MEX\", \"ROW\"], the examples above would be written as foo[\"USA\"] = Uniform(0, 1) and so on.","category":"page"},{"location":"howto/howto_3/#Apply-RVs-to-model-parameters:-Assigning-a-vector-of-distributions-1","page":"3 Monte Carlo + SA","title":"Apply RVs to model parameters: Assigning a vector of distributions","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In some cases, it's more convenient to assign a vector of distributions (e.g., with different functional forms or parameters) to a single parameter. For example we can use the following syntax:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"  foo = [USA => Uniform(0, 1),\n         (CAN, MEX) => Uniform(1, 2),\n         ROW => Normal(10, 3)]","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"which is equivalent to:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"  foo[USA] = Uniform(0, 1),\n  foo[(CAN, MEX)] = Uniform(1, 2),\n  foo[ROW] = Normal(10, 3)]","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"To assign to parameters with more than one dimension, use square brackets around the dimensions on the left-hand side of each => operator, e.g.,","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"  bar = [[2050, USA] => Uniform(0, 1),\n         [:, (CAN, MEX)] => Uniform(1, 2),\n         [2010:10:2080, ROW] => Normal(10, 3)]","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Currently, the more condensed syntax (using the pair operator =>) supports only direct assignment  of RV value, i.e., you cannot combine this with the *= or += operators.","category":"page"},{"location":"howto/howto_3/#Specify-a-Sampling-Strategies-1","page":"3 Monte Carlo + SA","title":"Specify a Sampling Strategies","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"As previously mentioned and included in the tutorial, the @defsim macro uses the call to sampling to type-parameterize the SimulationDef with one of three types, which in turn direct the sampling strategy of the simulation. This is done with the sampling line of the macro.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Simple random-sampling Monte Carlo Simulation (MCSData),\nLatin Hypercube Sampling (LHSData)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Latin Hypercube sampling divides the distribution into equally-spaced quantiles, obtains values at those quantiles, and then shuffles the values. The result is better representation of the tails of the distribution with fewer samples than would be required for purely random sampling.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Sobol sampling and analysis (SobolData)\nDelta sampling and analysis (DeltaData) - Beta, we don't recommend use yet","category":"page"},{"location":"howto/howto_3/#Include-Sampling-Strategy-specific-Parameters-1","page":"3 Monte Carlo + SA","title":"Include Sampling Strategy-specific Parameters","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Certain sampling strategies support (or necessitate) further customization. These may include:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"rank correlations (LHS)): In some cases, it may be desireable to define  rank correlations between pairs of random variables. Approximate rank correlation is achieved by re-ordering vectors of random draws as per Iman and Conover (1982). \nextra parameters (Sobol): Sobol sampling allows specification of the sample size N and whether or not one wishes to calculate second-order effects.","category":"page"},{"location":"howto/howto_3/#.-The-[run](@ref)-function-1","page":"3 Monte Carlo + SA","title":"2. The run function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In it's simplest use, the run function generates and iterates over generated trial data, perturbing a chosen subset of Mimi's model parameters, based on the defined distributions, and then runs the given Mimi model(s). The function retuns an instance of SimulationInstance, holding a copy of the original SimulationDef with additional trial information as well as a list of references ot the models and the results. Optionally, trial values and/or model results are saved to CSV files.","category":"page"},{"location":"howto/howto_3/#Function-signature-1","page":"3 Monte Carlo + SA","title":"Function signature","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The full signature for the run is:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;\n                 ntimesteps::Int=typemax(Int), \n                 trials_output_filename::Union{Nothing, AbstractString}=nothing, \n                 results_output_dir::Union{Nothing, AbstractString}=nothing, \n                 pre_trial_func::Union{Nothing, Function}=nothing, \n                 post_trial_func::Union{Nothing, Function}=nothing,\n                 scenario_func::Union{Nothing, Function}=nothing,\n                 scenario_placement::ScenarioLoopPlacement=OUTER,\n                 scenario_args=nothing,\n                 results_in_memory::Bool=true) where T <: AbstractSimulationData","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Using this function allows a user to run the simulation definition sim_def for the models using samplesize samples.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Optionally the user may run the models for ntimesteps, if specified, else to the maximum defined time period. Note that trial data are applied to all the associated models even when running only a portion of them.   ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"If provided, the generated trials and results will be saved in the indicated trials_output_filename and results_output_dir respectively. If results_in_memory is set to false, then results will be cleared from memory and only stored in the results_output_dir. After run, the results of a SimulationInstance can be accessed using the getdataframe function with the following signature, which returns a DataFrame. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"getdataframe(sim_inst::SimulationInstance, comp_name::Symbol, datum_name::Symbol; model::Int = 1)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"If pre_trial_func or post_trial_func are defined, the designated functions are called  just before or after (respectively) running a trial. The functions must have the signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"fn(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"where tup is a tuple of scenario arguments representing one element in the cross-product of all scenario value vectors. In situations in which you want the simulation loop to run only some of the models, the remainder of the runs can be handled using a pre_trial_func or post_trial_func.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"If provided, scenario_args must be a Vector{Pair}, where each Pair is a symbol and a  Vector of arbitrary values that will be meaningful to scenario_func, which must have the signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"scenario_func(sim_inst::SimulationInstance, tup::Tuple)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"By default, the scenario loop encloses the simulation loop, but the scenario loop can be placed inside the simulation loop by specifying scenario_placement=INNER. When INNER  is specified, the scenario_func is called after any pre_trial_func but before the model is run.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Finally, run returns the type SimulationInstance that contains a copy of the original SimulationDef in addition to trials information (trials, current_trial, and current_data), the model list models, and results information in results.","category":"page"},{"location":"howto/howto_3/#Internal-Functions-to-[run](@ref)-1","page":"3 Monte Carlo + SA","title":"Internal Functions to run","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The following functions are internal to run, and do not need to be understood by users but may be interesting to understand.","category":"page"},{"location":"howto/howto_3/#The-set_models!-function-1","page":"3 Monte Carlo + SA","title":"The set_models! function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The run function sets the model or models to run using set_models! function and saving references to these in the SimulationInstance instance.  The set_models! function has several methods for associating the model(s) to run with the SimulationDef:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"set_models!(sim_inst::SimulationInstance, models::Vector{Model})\nset_models!(sim_inst::SimulationInstance, m::Model)\nset_models!(sim_inst::SimulationInstance, mm::MarginalModel)","category":"page"},{"location":"howto/howto_3/#The-generate_trials!-function-1","page":"3 Monte Carlo + SA","title":"The generate_trials! function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The generate_trials! function is used to pre-generate data using the given samplesize and save all random variable values in the file filename. Its calling signature is:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"  generate_trials!(sim_def::SimulationDefinition, samplesize::Int; filename::Union{String, Nothing}=nothing)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"If the sim_def parameter has multiple scenarios and the scenario_loop placement is set to OUTER this function must be called if the user wants to ensure the same trial data be used in each scenario. If this function is not called, new trial data will be generated for each scenario. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Also note that if the filename argument is used, all random variable draws are saved to the given filename. Internally, any Distribution instance is converted to a SampleStore and the values are subsequently returned in the order generated when rand! is called.","category":"page"},{"location":"howto/howto_3/#Non-stochastic-Scenarios-1","page":"3 Monte Carlo + SA","title":"Non-stochastic Scenarios","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In many cases, scenarios (which we define as a choice of values from a discrete set for one or more parameters) need to be considered in addition to the stochastic parameter variation. To support scenarios, run also offers iteration over discrete scenario values, which are passed to run via the keyword parameter scenario_args::Dict{Symbol, Vector}. For example, to iterate over scenario values \"a\", and \"b\", as well as, say, discount rates 0.025, 0.05, 0.07, you could provide the argument:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"scenario_args=Dict([:name => [\"a\", \"b\"], :rate => [0.025, 0.05, 0.07]])","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Of course, the SA subsystem does not know what you want to do with these values, so the user must also provide a callback function in the scenario_func argument. This function must be defined with the signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"function any_name_you_like(sim_inst::SimulationInstance, tup)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"where tup is an element of the set of tuples produced by calling Itertools.product() on all the scenario arguments. In the example above, this would produce the following vector of tuples:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"[(\"a\", 0.025), (\"b\", 0.025), (\"a\", 0.03), (\"b\", 0.03), (\"a\", 0.05), (\"b\", 0.05)].","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"This approach allows all scenario combinations to be iterated over using a single loop. A final keyword argument, scenario_placement::ScenarioLoopPlacement indicates whether the scenario loop should occur inside or outside the loop over stochastic trial values. The type ScenarioLoopPlacement is an enum with values INNER and OUTER, the latter being the default placement.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In approximate pseudo-julia, these options produce the following behavior:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"scenario_placement=OUTER","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"for tup in scenario_tuples\n  scenario_func(tup)\n\n  # for each scenario, run all SA trials\n  for trial in trials\n    trial_data = get_trial_data(trial)\n    apply_trial_data()\n\n    pre_trial_func()\n    run(model)\n    post_trial_func()\n  end\nend","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"scenario_placement=INNER","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"for trial in trials\n  trial_data = get_trial_data(trial)\n  apply_trial_data()\n\n  # for each SA trial, run all scenarios\n  for tup in scenario_tuples\n    scenario_func(tup)\n\n    pre_trial_func()\n    run(model)\n    post_trial_func()\n  end\nend","category":"page"},{"location":"howto/howto_3/#Running-Multiple-Models-1","page":"3 Monte Carlo + SA","title":"Running Multiple Models","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In some simulations, a baseline model needs to be compared to one or more models that are perturbed parametrically or structurally (i.e., with different components or equations.) To support this, the SimulationInstance type holds a vector of Model instances, and allows the caller to specify how many of these to run automatically for each trial. Note that regardless of how many models are run, the random variables are applied to all of the models associated with the simulation.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"By default, all defined models are run. In some cases, you may want to run some of the models \"manually\" in the pre_trial_func or post_trial_func, which allow you to make arbitrary modifications to these additional models.","category":"page"},{"location":"howto/howto_3/#.-The-analyze-function-1","page":"3 Monte Carlo + SA","title":"3. The analyze function","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The analyze function takes a simulation instance, runs a sensitivity analysis method as determined by the type of simulation instance, and returns the results. It is currently defined for a SobolSimulationInstance and the DeltaSimulationInstance (Beta) subtypes of SimulationInstance.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"This function wraps the analyze function in the GlobalSensitivityAnalysis.jl package, so please view the README of this package for the most up to date information. ","category":"page"},{"location":"howto/howto_3/#.-Plotting-and-the-Explorer-UI-1","page":"3 Monte Carlo + SA","title":"4. Plotting and the Explorer UI","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"As described in the User Guide, Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI and Mimi.plot function. These functions not only work for Models, but for SimulationInstances as well. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"In order to invoke the explorer UI and explore all of the saved variables from the save list of a SimulationInstance, simply call the function explore with the simulation as the required argument as shown below.  This will produce a new browser window containing a selectable list of variables, each of which produces a graphic.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"run(sim_inst)\nexplore(sim_inst)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"There are several optional keyword arguments for the explore method, as shown by the full function signature:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"explore(sim_inst::SimulationInstance; title=\"Electron\", model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The title is the optional title of the application window, the model_index defines which model in your list of models passed to run you would like to explore (defaults to 1), and scen_name is the name of the specific scenario you would like to explore if there is a scenario dimension to your simulation.  Note that if there are multiple scenarios, this is a required argument. Finally, if you have saved the results of your simulation to disk and cleared them from memory using run's results_in_memory keyword argument flag set to false, you must provide a results_output_dir which indicates the parent folder for all outputs and potential subdirectories, identical to that passed to run.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"(Image: Explorer Simulation Example)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Alternatively, in order to view just one variable, call the (unexported) function Mimi.plot as below to return a plot object and automatically display the plot in a viewer, assuming Mimi.plot is the last command executed.  Note that plot is not exported in order to avoid namespace conflicts, but a user may import it if desired. This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved in many typical file formats such as  PNG, SVG, PDF and EPS files. You may save a plot using the save function. Note that while explore(sim_inst) returns interactive plots for several graphs, Mimi.plot(si, :foo, :bar) will return only static plots. ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"using VegaLite\nrun(sim_inst)\np = Mimi.plot(sim_inst, :component1, :parameter1)\nsave(\"figure.svg\", p)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Note the function signature below, which has the same keyword arguments and requirements as the aforementioned explore method, save for title.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"plot(sim_inst::SimulationInstance, comp_name::Symbol, datum_name::Symbol; interactive::Bool = false, model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"(Image: Plot Simulation Example)","category":"page"},{"location":"howto/howto_3/#.-Other-Useful-Functions-1","page":"3 Monte Carlo + SA","title":"5. Other Useful Functions","text":"","category":"section"},{"location":"howto/howto_3/#Simulation-Modification-Functions-1","page":"3 Monte Carlo + SA","title":"Simulation Modification Functions","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"A small set of unexported functions are available to modify an existing SimulationDefinition.  The functions include:","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"delete_RV!(sim_def::SimulationDef, name::Symbol) - deletes the random variable with name name from the Simulation Definition sim_def, along with all transformations using that random variable\nadd_RV!(sim_def::SimulationDef, name::Symbol, dist::Distribution) - add the random variable with the name name from the Simulation Definition sim_def \nreplace_RV!(sim_def::SimulationDef, name::Symbol, dist::Distribution) - replace the random variable with name name in Simulation Definition with a random variable of the same name but with the distribution Distribution\ndelete_transform!(sim_def::SimulationDef, name::Symbol)! - Delete all data transformations in Simulation Definition sim_def (i.e., replacement, addition or multiplication) of original data values with values drawn from the random variable named name\nadd_transform!(sim_def::SimulationDef, paramname::Symbol, op::Symbol, rvname::Symbol, dims::Vector=[])! - Create a new TransformSpec based on paramname, op, rvname and dims to the Simulation Definition sim_def. The symbol rvname must refer to an existing random variable, and paramname must refer to an existing shared model parameter that can thus be accessed by that name. Use the following signature if your paramname is an unshared model parameter specific to a component. If dims are provided, these must be legal subscripts of paramname. Op must be one of :+=, :*=, or :(=).\nadd_transform!(sim_def::SimulationDef, compname::Symbol, paramname::Symbol, op::Symbol, rvname::Symbol, dims::Vector=[])! - Create a new TransformSpec based on compname, paramname, op, rvname and dims to the Simulation definition sim_def, and update the Simulation's NamedTuple type. The symbol rvname must refer to an existing RV, and compname and paramname must holding an existing component and parameter. If dims are provided, these must be legal subscripts of paramname. Op must be one of :+=, :*=, or :(=).","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"For example, say a user starts off with a SimulationDefinition MySimDef with a parameter MyParameter drawn from the random variable MyRV with distribution Uniform(0,1).  ","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Case 1: The user wants this random variable to draw from a new distribution, say Normal(0,1), which will affect all parameters with transforms attached to this random variable.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"using Distributions\nusing Mimi\nreplace_RV!(MySimDef, MyRV, Normal(0,1))","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"Case 2: The user parameter MyParameter to to take on the value of a random draw from a Normal(2,0.1) distribution.  We assume this requires a new random variable, because no random variable has this distribution yet.","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"using Distributions\nusing Mimi\nadd_RV!(MySimDef, :NewRV, Normal(2, 0.1))\nadd_transform!(MySimDef, :MyParameter, :=, :NewRV)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"add_save!(sim_def::SimulationDef, comp_name::Symbol, datum_name::Symbol) - Add to Simulation Definitionsim_def a \"save\" instruction for component comp_name and parameter or variable datum_name. This result will be saved to a CSV file at the end of the simulation.    \ndelete_save!(sim_def::SimulationDef, comp_name::Symbol, datum_name::Symbol) - Delete from Simulation Definition sim_def a \"save\" instruction for component comp_name and parameter nor variable datum_name. This result will no longer be saved to a CSV file at the end of the simulation.","category":"page"},{"location":"howto/howto_3/#Helper-Functions-1","page":"3 Monte Carlo + SA","title":"Helper Functions","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"\"\"\"\n  get_simdef_rvnames(sim_def::SimulationDef, name::Union{String, Symbol})\n\nA helper function to support finding the keys in a Simulation Definition `sim_def`'s\nrvdict that contain a given `name`. This can be particularly helpful if the random \nvariable was set via the shortcut syntax ie. my_parameter = Normal(0,1) and thus the\n`sim_def` has automatically created a key in the format `:my_parameter!x`. In this \ncase this function is useful to get the key and carry out modification functions \nsuch as `replace_rv!`.\n\"\"\"\n\nfunction get_simdef_rvnames(sim_def::SimulationDef, name::Union{String, Symbol})\n    names = String.([keys(sim_def.rvdict)...])\n    matches = Symbol.(filter(x -> occursin(String(name), x), names))\nend","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"As shown in the examples below, and described above, parameters can be assigned unique random variables under the hood without explicitly declaring the RV.  Fore example, instead of pairing","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"rv(name) = Uniform(0.2, 0.8)\nshare = name1","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"we can write","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"share = Uniform(0.2, 0.8)","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"When this is done, Mimi will create a new unique RV with a unique name share!x where x is an integer determined by internal processes that gaurantee it to be unique in this sim_def.  This syntax is therefore not recommended if the user expects to want to reference that random variable using the aforementioned modification functions.  That said, if the user does need to do so we have added a helper function get_simdef_rvnames(sim_def::SimulationDef, name::Union{String, Symbol}) which will return the unique names of the random variables that start with name.  In the case above, for example, get_simdef_rvnames(sim_def, :share) would return [share!x].  In a case where share had multiple dimensions, like three regions, it would return [share!x1, share!x2, share!x3].  ","category":"page"},{"location":"howto/howto_3/#Payload-Functions-1","page":"3 Monte Carlo + SA","title":"Payload Functions","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"set_payload!\npayload","category":"page"},{"location":"howto/howto_3/#.-Examples-1","page":"3 Monte Carlo + SA","title":"6. Examples","text":"","category":"section"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"The following example is derived from \"Mimi.jl/test/mcs/test_defmcs.jl\".","category":"page"},{"location":"howto/howto_3/#","page":"3 Monte Carlo + SA","title":"3 Monte Carlo + SA","text":"using Mimi\nusing Distributions\n\nN = 100\n\nsd = @defsim begin\n    # Define random variables. The rv() is required to disambiguate an\n    # RV definition name = Dist(args...) from application of a distribution\n    # to a model parameter. This makes the (less common) naming of an\n    # RV slightly more burdensome, but it's only required when defining\n    # correlations or sharing an RV across parameters.\n    rv(name1) = Normal(1, 0.2)\n    rv(name2) = Uniform(0.75, 1.25)\n    rv(name3) = LogNormal(20, 4)\n\n    # assign RVs to model Parameters\n    share = Uniform(0.2, 0.8)\n    sigma[:, Region1] *= name2\n    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)\n\n    depk = [Region1 => Uniform(0.08, 0.14),\n            Region2 => Uniform(0.10, 1.50),\n            Region3 => Uniform(0.10, 0.20)]\n\n    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])\n    \n    # indicate which parameters to save for each model run. Specify\n    # a parameter name or [later] some slice of its data, similar to the\n    # assignment of RVs, above.\n    save(grosseconomy.K, grosseconomy.YGROSS, emissions.E, emissions.E_Global)\nend\n\nMimi.reset_compdefs()\ninclude(\"../../examples/tutorial/02-multi-region-model/main.jl\")\n\nm = model\n\n# Optionally, user functions can be called just before or after a trial is run\nfunction print_result(m::Model, sim_inst::SimulationInstance, trialnum::Int)\n    ci = Mimi.compinstance(m.mi, :emissions)\n    value = Mimi.get_variable_value(ci, :E_Global)\n    println(\"$(ci.comp_id).E_Global: $value\")\nend\n\n# set some some constants\ntrials_output_filename = joinpath(output_dir, \"trialdata.csv\")\nresults_output_dir = joinpath(tempdir(), \"sim\")\nN = 100\n\n# Run trials and save trials results to the indicated directories\nsi = run(sd, m, N; trials_output_filename=trials_output_filename, results_output_dir=results_output_dir)\n\n# take a look at the results\nresults = getdataframe(si, :grosseconomy, :K) # model index chosen defaults to 1","category":"page"},{"location":"howto/howto_5/#How-to-Guide-5:-Work-with-Parameters-and-Variables-1","page":"5 Parameters + Variables","title":"How-to Guide 5: Work with Parameters and Variables","text":"","category":"section"},{"location":"howto/howto_5/#Parameters-1","page":"5 Parameters + Variables","title":"Parameters","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Component parameters in Mimi obtain values either (1) from a variable calculated by another component and passed through an internal connection or (2) from an externally set value stored in a model parameter.  For the latter case, model parameters can be unshared, such that they can only connect to one component/parameter pair and must be accessed by specifying both the component and component's parameter name, or shared, such that they can connect to multiple component/parameter pairs and have a unique name they can be referenced with. ","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"In the next few subsections we will present the API for setting, connecting, and updating parameters as presented by different potential use cases. The API consists of only a few primary functions:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_param!\nadd_shared_param!\ndisconnect_param!\nconnect_param!","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"along with the useful functions for batch setting:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_params!\nupdate_leftover_params!","category":"page"},{"location":"howto/howto_5/#Parameters-when-Creating-a-Model-1","page":"5 Parameters + Variables","title":"Parameters when Creating a Model","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Take the example case of a user starting out building a two-component toy model.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"@defcomp A begin\n    p1 = Parameter(default = 2)\n    p2 = Parameter(index = [time])\n\n    v1 = Variable()\n\n    function run_timestep(p, v, d, t)\n        v.v1 = p.p1\n    end\nend\n\n@defcomp B begin\n    p3 = Parameter()\n    p4 = Parameter(index = [time])\n    p5 = Parameter()\n\n    v2 = Variable()\n    function run_timestep(p, v, d, t)\n        v.v2 = p.p3\n    end\nend\n\nm = Model()\nset_dimension!(m, :time, 2000:2005)\nadd_comp!(m, A)\nadd_comp!(m, B)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"After the calls to add_comp!, all four parameters are connected to a respective unshared model parameter.  These unshared model parameters for A's, p2, B's p3 and p4 hold sentinel values of nothing, while that connected to A's p1 holds the value 2 as designated by the call to the default argument.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"At this point, you cannot run(m), you will encounter:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"run(m)\nERROR: Cannot build model; the following parameters still have values of nothing \nand need to be updated or set:\n  p2 (in Component A)\n  p3 (in Component B)\n  p4 (in Component B)\n  p5 (in Component B)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Per the above, we need to update these parameters so that they are connected to a non-nothing value.  We have three cases here, (1) we want to update the value of an unshared parameter from nothing to a value, (2) we want to add a shared parameter and connect one or, more commonly, several component parameters to it, or (3) we want to connect a parameter to another component's variable.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Case 1: In the first case, we simply call update_param! ie.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_param!(m, :B, :p3, 5)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"The dimensions and datatype of the value set above will need to match those designated for the component's parameter, or corresponding appropriate error messages will be thrown. ","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Case 2: In the second case, we will explicitly create and add a shared model parameter with add_shared_param! and then connect the parameters with connect_param! ie.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"add_shared_param!(m, :shared_param, [1,2,3,4,5,6], dims = [:time])\nconnect_param!(m, :A, :p2, :shared_param)\nconnect_param!(m, :B, :p4, :shared_param)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"The shared model parameter can have any name, including the same name as one of the component parameters, without any namespace collision with those, although for clarity we suggest using a unique name.  ","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Importantly, add_shared_param! has two optional keyword arguments, dims and data_type, which mirror specifications you gave in your @defcomp parameter definition and might be needed. Again we include error messages to alert you of this.  Specifically:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"dims::Vector{Symbol}: If your shared model parameter will be connected to parameters with dimensions, like one defined in @defcomp with p = Parameter(index = [time]), you'll need to specify dimensions with add_shared_param!(m, :model_param_name, value; dims = [time]).  \ndata_type::DataType: If your shared model parameter will be connected to parameters with dimensions, like one defined in @defcomp with p = Parameter{Int64}(), you may need to specify dimensions with add_shared_param!(m, :model_param_name, value; data_type = Int64) although we will try to interpret this under the hood for you.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Appropriate error messages will instruct you to designate these if you forget to do so, and also recognize related problems with connections to parameters.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Case 3.: In the third case we want to connect B's p5 to A's v1, and we can do so with:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"connect_param!(m, :B, :p5, :A, :v1)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Now all your parameters are properly connected and you may run your model.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"run(m)","category":"page"},{"location":"howto/howto_5/#Parameters-when-Modifying-a-Model-1","page":"5 Parameters + Variables","title":"Parameters when Modifying a Model","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Now say we have been given our model m above and we want to make some changes. Below we use some explicit examples that  together should cover quite a few general cases.  If something is not covered here that would be a useful case for us to explicitly explain, don't hesitate to reach out. We have also aimed to include useful warnings and error messages to point you in the right direction.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"To update a parameter connected to an unshared model parameter, use the same update_param! function as above:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_param!(m, :A, :p1, 5)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Trying this call when A's parameter p1 is connected to a shared parameter will error, and instruct you on the steps to use to either update the shared model parameter, or disconnect A's p1 from that shared model parameter and then proceed, both as explained below.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"To update parameters connected to a shared model parameter, use update_param!  with different arguments, specifying the shared model parameter name:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_param!(m, :shared_param, 5)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"To connect a parameter to another component's variable, the below will disconnect any existing connections from B's p3 (disconnect_param! under the hood) and make the internal parameter connection to A's v1: ","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"connect_param!(m, :B, :p3, :A, :v1)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Symmetrically, a subsequent call to update_param! would remove the internal connection and connect instead to an unshared model parameter as was done in the original m:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_param!(m, :B, :p3, 10)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"To move from an external connection to a shared model parameter to an external connection to an unshared model parameter use disconnect_param! followed by update_param! :","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"disconnect_param!(m, :A, :p2)\nupdate_param!(m, :A, :p2, [101, 102, 103, 104, 105, 106])","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"noting that this last call could also be a connect_param! to another parameter or variable etc., A's p2 is now free to be reset in any way you want.","category":"page"},{"location":"howto/howto_5/#Other-Details-1","page":"5 Parameters + Variables","title":"Other Details","text":"","category":"section"},{"location":"howto/howto_5/#Units-1","page":"5 Parameters + Variables","title":"Units","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"In some cases you may have a model that specifies the units of parameters:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"@defcomp A begin\n    p1 = Parameter(unit = \"\\$\")\n    function run_timestep(p, v, d, t)\n    end\nend\n\n@defcomp B begin\n    p2 = Parameter(unit = \"thousands of \\$\")\n    function run_timestep(p, v, d, t)\n    end\nend\n\nm = Model()\nset_dimension!(m, :time, 2000:2005)\nadd_comp!(m, A)\nadd_comp!(m, B)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"If you want to connect p1 and p2 to the same shared model parameter, you will encounter an error because the units do not match:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"add_shared_param!(m, :shared_param, 100)\nconnect_param!(m, :A, :p1, :shared_param) # no error here\nconnect_param!(m, :B, :p2, :shared_param)\n\nERROR: Units of compdef:p2 (thousands of $) do not match the following other \nparameters connected to the same shared model parameter shared_param.  To override \nthis error and connect anyways, set the `ignoreunits` flag to true: \n`connect_param!(m, comp_def, param_name, model_param_name; ignoreunits = true)`. \nMISMATCHES OCCUR WITH: [A:p1 with units $]  ","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"As you see in the error message, if you want to override this error, you can use the ignoreunits flag:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"connect_param!(m, :B, :p2, :shared_param, ignoreunits=true)","category":"page"},{"location":"howto/howto_5/#Batch-Update-all-Unset-Parameters-with-a-Dictionary-1","page":"5 Parameters + Variables","title":"Batch Update all Unset Parameters with a Dictionary","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"When building up a model, you may end up with several parameters that have not been explicitly updated that you want to batch update with pre-computer and saved values (ie. in a csv file). Before this update, the values still hold the a unusable sentinal value of nothing from intialization. A model with such parameters is not runnable.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"The update_leftover_params! call takes a model and dictionary and updates the values of each the sentinal nothing model parameters by searching for their corresponding (component_name, parameter_name) pair in the provided dictionary with entries k => v, where k is a Tuple of Strings or Symbols (component_name, parameter_name).  The signature for this function is","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_leftover_params!(m::Model, parameters::Dict)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"For example, given a model m with with component A's parameters p1 and p2 which have not been updated from nothing, along with component B's parameter p1 that has not been updated.  In this case the following will update those parameters and make the model runnable:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"parameters = Dict((:A, :p1) => 1, (:A, :p2) => :foo, (:B, :p1) => 100)\nupdate_leftover_params!(m, parameters)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"Note that your dictionary parameters must include all leftover parameters that need to be set, not just a subset of them, or it will error when it cannot find a desired key.","category":"page"},{"location":"howto/howto_5/#Batch-Update-Specified-Parameters-with-a-Dictionary-1","page":"5 Parameters + Variables","title":"Batch Update Specified Parameters with a Dictionary","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"You can batch update a defined set of parameters using a Dict and the function update_params!.  You can do so for any set of unshared or shared model parameters.  The signature for this function is:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"update_params!(m::Model, parameters::Dict)","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"For each (k, v) pair in the provided parameters dictionary, update_param! is called to update the model parameter identified by the key to value v. For updating unshared parameters, each key k must be a Tuple matching the name of a component in m and the name of an parameter in that component. For updating shared parameters, each key k must be a symbol or convert to a symbol  matching the name of a shared model parameter that already exists in the model.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"For example, given a model m with a shared model parameter shared_param connected to several component parameters, and two unshared model parameters p1 and p2 in a component A:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"# update shared model parameters and unshared model parameters separately\nshared_dict = Dict(:shared_param => 1)\nunshared_dict = Dict((:A, :p5) => 2, (:A, :p6) => 3)\nupdate_params!(m, shared_dict)\nupdate_params!(m, unshared_dict)\n\n# update both at the same time\ndict = Dict(:shared_param => 1, (:A, :p5) => 2, (:A, :p6) => 3)\nupdate_params!(m, dict)","category":"page"},{"location":"howto/howto_5/#Anonymous-Parameter-Indices-1","page":"5 Parameters + Variables","title":"Anonymous Parameter Indices","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"As mentioned above, a parameter can have no index (a scalar), or one or multiple of the model's indexes. A parameter can also have an index specified in the following ways:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"@defcomp MyComponent begin\n  p1 = Parameter(index=[4]) # an array of length 4\n  p2 = Parameter{Array{Float64, 2}}() # a two dimensional array of unspecified length\nend","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"In both of these cases, the parameter's values are stored of as an array (p1 is one dimensional, and p2 is two dimensional). But with respect to the model, they are considered \"scalar\" parameters, simply because they do not use any of the model's indices (namely 'time', or 'regions').","category":"page"},{"location":"howto/howto_5/#Using-NamedArrays-for-Setting-Parameters-1","page":"5 Parameters + Variables","title":"Using NamedArrays for Setting Parameters","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"When a user sets a parameter, Mimi checks that the size and dimensions match what it expects for that component. If the user provides a NamedArray for the values, Mimi will further check that the names of the dimensions match the expected dimensions for that parameter, and that the labels match the model's index values for those dimensions. Examples of this can be found in \"test/testparameterlabels.jl\".","category":"page"},{"location":"howto/howto_5/#Variables-1","page":"5 Parameters + Variables","title":"Variables","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"[TODO]","category":"page"},{"location":"howto/howto_5/#DataType-specification-of-Parameters-and-Variables-1","page":"5 Parameters + Variables","title":"DataType specification of Parameters and Variables","text":"","category":"section"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"By default, the Parameters and Variables defined by a user will be allocated storage arrays of type Float64 when a model is constructed. This default \"number_type\" can be overriden when a model is created, with the following syntax:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"m = Model(Int64)    # creates a model with default number type Int64","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"But you can also specify individual Parameters or Variables to have different data types with the following syntax in a @defcomp macro:","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"@defcomp example begin\n  p1 = Parameter{Bool}()                         # ScalarModelParameter that is a Bool\n  p2 = Parameter{Bool}(index = [regions])        # ArrayModelParameter with one dimension whose eltype is Bool\n  p3 = Parameter{Matrix{Int64}}()                # ScalarModelParameter that is a Matrix of Integers\n  p4 = Parameter{Int64}(index = [time, regions]) # ArrayModelParameter with two dimensions whose eltype is Int64\nend","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"If there are \"index\"s listed in the Parameter definition, then it will be an ArrayModelParameter whose eltype is the type specified in the curly brackets. If there are no \"index\"s listed, then the type specified in the curly brackets is the actual type of the parameter value, and it will be represent by Mimi as a ScalarModelParameter.","category":"page"},{"location":"howto/howto_5/#","page":"5 Parameters + Variables","title":"5 Parameters + Variables","text":"If you use this functionality and then connect_param! these Parameters to model parameters, you may need to  use the data_type keyword argument to specifiy the desired DataType of your connected parameter.","category":"page"},{"location":"ref/ref_structures_instances/#Reference-Guide:-Structures-Instances-1","page":"Structures: Instances","title":"Reference Guide: Structures - Instances","text":"","category":"section"},{"location":"ref/ref_structures_instances/#Models-and-Components-1","page":"Structures: Instances","title":"Models and Components","text":"","category":"section"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# ComponentInstance\ncomp_name::Symbol\ncomp_id::ComponentID\ncomp_path::ComponentPath (from top (model) down)\nfirst::Int\nlast::Int","category":"page"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# LeafComponentInstance <: ComponentInstance\nvariables::ComponentInstanceVariables\nparameters::ComponentInstanceParameters\ninit::Union{Nothing, Function}\nrun_timestep::Union{Nothing, Function}","category":"page"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# CompositeComponentInstance <: ComponentInstance\ncomps_dict::OrderedDict{Symbol, ComponentInstance}\nparameters::NamedTuple\nvariables::NamedTuple","category":"page"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# ModelInstance <: CompositeComponentInstance\nmd::ModelDef","category":"page"},{"location":"ref/ref_structures_instances/#Datum-1","page":"Structures: Instances","title":"Datum","text":"","category":"section"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# ComponentInstanceParameters (only exist in leaf component instances)\nnt::NamedTuple{Tuple{Symbol}, Tuple{Type}}    # Type is either ScalarModelParameter (for scalar parameters) or TimestepArray (for array parameters)\ncomp_paths::Vector{ComponentPath}","category":"page"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"Note: In the ComponentInstanceParameters, the values stored in the named tuple point to the actual variable arrays in the other components for things that are internally connected, or to the actual value stored in the mi.md.model_params dictionary if it's a model parameter.","category":"page"},{"location":"ref/ref_structures_instances/#","page":"Structures: Instances","title":"Structures: Instances","text":"# ComponentInstanceVariables (only exist in leaf component instances)\nnt::NamedTuple{Tuple{Symbol}, Tuple{Type}}  # Type is either ScalarModelParameter (for scalar variables) or TimestepArray (for array variables)\ncomp_paths::Vector{ComponentPath}","category":"page"},{"location":"howto/howto_main/#How-to-Guides-Introduction-1","page":"How-to Guides Intro","title":"How-to Guides Introduction","text":"","category":"section"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"The following how-to guides provide steps to work through several common real-world problems that Mimi is targeted at solving. They are a bit less detailed than the tutorials, and are thus targeted at a user with some level of experience with Mimi (likely obtained through moving through some or all of the tutorials). ","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"If you find a bug in these guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"howto/howto_main/#Available-How-to-Guides-1","page":"How-to Guides Intro","title":"Available How-to Guides","text":"","category":"section"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 1: Construct and Run a Model ","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 2: View and Explore Model Results ","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 3: Conduct Monte Carlo Simulations and Sensitivity Analysis","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 4: Work with Timesteps","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 5: Work with Parameters and Variables","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 6: Update the Time Dimension","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 7: Port to Mimi v0.5.0","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 8: Port from (>=) Mimi v0.5.0 to Mimi v1.0.0","category":"page"},{"location":"howto/howto_main/#","page":"How-to Guides Intro","title":"How-to Guides Intro","text":"How-to Guide 9: Port to New Parameter API","category":"page"},{"location":"internals/proposals/#Not-Implemented-(Yet)-1","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"This section describes proposed API and file formats that haven't been developed yet.","category":"page"},{"location":"internals/proposals/#ModelRunner-1","page":"Not Implemented (Yet)","title":"ModelRunner","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"There are several types of analyses that require an ensemble of model runs performed over a set of parameter values. These include traditional Monte Carlo simulation, in which random values are drawn from distributions and applied to model parameters, as well as global sensitivity analyses that use prescribed methods for defining trial data (e.g., Sobol sampling), and Markov Chain Monte Carlo, which computes new trial data based on prior model results.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The abstract type ModelRunner will be used to define a generic API for model runners, including support for parallelization of analyses on multiprocessors and cluster computing systems. The specific sampling and analysis methods required for each subtype of ModelRunner will be defined in the concrete subtype, e.g., SimulationRunner.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The generic process will look something like this:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"m = ModelDef(...)\nr = SimRunner(m)\n\n# Optionally redefine random variables, overriding defaults\nsetrv!(r, :rvname1, Normal(10, 3))\n\n# Optionally assign an alternative RV or distribution to a model parameter\nsetparam!(r, :comp1, :param1, :rvname1)\nsetparam!(r, :comp1, :param2, Uniform(0, 3))\n\n# Adjust what should be saved per model run\n@add_results(r, param10, param11[US])\n@drop_results(r, param1, param1)\n\n# Run trials 1-5000. Also can specify as a range (e.g., 5001:10000) \n# or vector of trial numbers.\nrun!(r, 5000)\n\n# Save results to the indicated directory\nwrite(r, dirname)","category":"page"},{"location":"internals/proposals/#Saving-ensemble-results-1","page":"Not Implemented (Yet)","title":"Saving ensemble results","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Ensemble results will be stored in an object of type EnsembleResult, which is used by all subtypes of ModelRunner. By default, only model outputs tagged for output will be saved in the EnsembleResult instance. Parameters can be identified as \"output\" parameters in @defsim, and/or directly in a concrete subtype of ModelRunner, in which case default values set in @defsim can be overridden.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The method write(r::ModelRunner, dirname::String) will save model results to set of CSV files in the named directory. Initially, we will store the data in tidy format in which variables are in columns and each row represents an observation. This format is verbose but flexible and commonly used by consumers of data such as plotting packages. Other formats can be generated if the need arises.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"In the initial implementation, results will be saved as follows:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Scalar model results will be written to \"$dirname/scalars.csv\". The file will have a column holding the trial number, and one column labeled with each parameter name. Each row in the file will contain all scalar parameter values data for a single  model run. \nExample:\ntrialnum foo bar baz ...\n1 1.6 0.4 110 ...\nAlternatively, we could flatten to 3 columns: \ntrialnum paramname value\n1 foo 1.6\n1 bar 0.4\n1 baz 110\nAll model results with a single time dimension will be written to \"$dirname/timeseries.csv\", with columns:\ntrialnum year foo bar baz ...\n1 2010 100.6 41.6 9.1 ...\n1 2015 101.7 44.5 10.2 ...\n1 2020 102.8 50.1 12.4 ...\n... ... ... ... ... ...\n2 2010 101.6 43.7 10.4 ...\n2 2015 102.4 60.1 21.3 ...\n2 2020 105.7 55.3 14.2 ...\n... ... ... ... ... ...\nAs with scalar results, this might be flattened further to:\ntrialnum paramname year value\n1 foo 2010 100.6\n1 foo 2015 101.7\n1 foo 2020 102.8\n... ... ... ...\n2 foo 2010 101.6\n2 foo 2015 102.4\n2 foo 2020 105.7\n... ... ... ...\nAnother alternative would be to store each timeseries result to its own CSV file, in which case the second (flattened) format would be used, minus the \"paramname\" column, which would be implicit from the filename. This would be more consistent with the matrix format below, since a timeseries result is just a matrix result with only one dimension.\nMatrix results will be saved to individual files named \"$dirname/$paramname.csv\". Matrices will be flattened so that each dimension appears as a column. For example, a matrix with dimensions \"time\" and \"region\" will have columns \"trialnum\", \ntrialnum region year value\n1 US 2010 1.1\n1 US 2015 1.9\n...   \n1 CHI 2010 0.2\n1 CHI 2015 0.8\n...   \nAnother option for saving ensemble outputs might include writing to any \"sink\" type that accepts named tuples.","category":"page"},{"location":"internals/proposals/#Model-result-file-format-1","page":"Not Implemented (Yet)","title":"Model result file format","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"To facilitate post-processing, model results will be saved to files in either JSON formats, as detailed below. To save results, the following methods can be used.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"For individual model runs, results can be saved to a single file, or added to an existing file. For SA simulations, a single JSON file will hold the subset  of results specified by the user, for each trial. This may become unwieldy, but we support gzipped JSON, which helps a bit: if a filename ends in  .gz, it will automatically be zipped on writing and gzipped on reading.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"saveresults(m::Model, pathname::String)\n\nsaveresults(m::Model, pathname::String, append=true)\n\nsaveresults(sim:Simulation, pathname::String)","category":"page"},{"location":"internals/proposals/#JSON-file-format-1","page":"Not Implemented (Yet)","title":"JSON file format","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The JSON file format is basically a set of nested dictionaries, with a few lists at the innermost levels. We assign names to these levels for clarity of exposition in this documentation, but these names do not exist in the actual files.","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"We specify dicttype=DataStructures.OrderedDict when reading and writing JSON files to ensure that insertion order is maintained.","category":"page"},{"location":"internals/proposals/#Scenario-dict-1","page":"Not Implemented (Yet)","title":"Scenario dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The top level of the JSON file is a dictionary keyed by scenario name (for non-SA results) or trial number (basically a numeric scenario name) for SA results.","category":"page"},{"location":"internals/proposals/#Index-Variable-Parameter-(IVP)-dict-1","page":"Not Implemented (Yet)","title":"Index-Variable-Parameter (IVP) dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"The value of the top-level dictionary is a dictionary whose keys are types of model inputs and results, which is currently one of \"Index\", \"Variable\", or \"Parameter\" of these dictionaries vary by the type of object stored, as shown below.","category":"page"},{"location":"internals/proposals/#Index-dict-1","page":"Not Implemented (Yet)","title":"Index dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"An index dict is keyed by index name (e.g., \"time\", \"region\") with values being lists of index values. For example the \"time\" index might look like this:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"\"time\" : [2010, 2011, 2012, 2013, ..., 2099, 2100]","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"These are converted to Index objects upon reading.","category":"page"},{"location":"internals/proposals/#Variable-dict-1","page":"Not Implemented (Yet)","title":"Variable dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Variable dicts are keyed by a string of the form \"$component_name:$variable_name\" (tuple keys are not supported in JSON). Values are single numerical values for scalar parameters, or for vector and matrix values, a list of lists of the form [[dimensions...], [values...]] where dimensions. Examples:","category":"page"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"{\n # Scalar\n \"foo\" : 42,\n\n # one dimension\n \"bar\" : [[\"region\"], [4.1, 7.2, 3.6, 9.4, 5.5, 7.6, ...],\n\n # two dimensions are stored as arrays of arrays\n \"baz\" : [\n   [\"time\", \"region\"], \n   [[4.1, 7.2, 3.6, ...], # values by region for first timestep\n    [3.5, 6.3, 5.6, ...], # values by region for 2nd timestep\n    ...]\n  ]\n}","category":"page"},{"location":"internals/proposals/#Parameter-dict-1","page":"Not Implemented (Yet)","title":"Parameter dict","text":"","category":"section"},{"location":"internals/proposals/#","page":"Not Implemented (Yet)","title":"Not Implemented (Yet)","text":"Parameter dicts are keyed by model parameter names (symbols), with values represented in the same format as shown above for Variable dicts.","category":"page"},{"location":"ref/ref_API/#Reference-Guide:-The-Mimi-API-1","page":"Mimi API","title":"Reference Guide: The Mimi API","text":"","category":"section"},{"location":"ref/ref_API/#","page":"Mimi API","title":"Mimi API","text":"@defcomp\n@defsim\n@defcomposite\nMarginalModel\nModel\nadd_comp!\nadd_shared_param!\nconnect_param!\ncreate_marginal_model\ndelete_param!\ndim_count\ndim_keys\ndim_key_dict\ndisconnect_param!\nexplore\ngetdataframe\ngettime\nget_param_value\nget_var_value\nhasvalue\nis_first\nis_last\nis_time\nis_timestep\nmodeldef\nnameof\nparameter_dimensions\nparameter_names\nreplace!\nreplace_comp!\nrun\nset_dimension!\nset_leftover_params!\nset_param!\nTimestepIndex\nTimestepValue\nupdate_param!\nupdate_params!\nupdate_leftover_params!\nvariable_dimensions\nvariable_names","category":"page"},{"location":"ref/ref_API/#Mimi.@defcomp","page":"Mimi API","title":"Mimi.@defcomp","text":"defcomp(comp_name::Symbol, ex::Expr)\n\nDefine a Mimi component comp_name with the expressions in ex.  The following  types of expressions are supported:\n\ndimension_name = Index()   # defines a dimension\nparameter = Parameter(index = [dimension_name], units = \"unit_name\", default = default_value)    # defines a parameter with optional arguments\nvariable = Variable(index = [dimension_name], units = \"unit_name\")    # defines a variable with optional arguments\ninit(p, v, d)              # defines an init function for the component\nrun_timestep(p, v, d, t)   # defines a run_timestep function for the component\n\nParses a @defcomp definition, converting it into a series of function calls that create the corresponding ComponentDef instance. At model build time, the ModelDef (including its ComponentDefs) will be converted to a runnable model.\n\n\n\n\n\n","category":"macro"},{"location":"ref/ref_API/#Mimi.@defsim","page":"Mimi API","title":"Mimi.@defsim","text":"defsim(expr::Expr)\n\nDefine a Mimi SimulationDef with the expressions in expr.  \n\n\n\n\n\n","category":"macro"},{"location":"ref/ref_API/#Mimi.@defcomposite","page":"Mimi API","title":"Mimi.@defcomposite","text":"defcomposite(cc_name, ex)\n\nDefine a Mimi CompositeComponentDef cc_name with the expressions in ex. Expressions are all shorthand for longer-winded API calls, and include the following:\n\np = Parameter(...)\nv = Variable(varname)\nlocal_name = Component(name)\nComponent(name)  # equivalent to `name = Component(name)`\nconnect(...)\n\nVariable names are expressed as the component id (which may be prefixed by a module, e.g., Mimi.adder) followed by a . and the variable name in that component. So the form is either modname.compname.varname or compname.varname, which must be known in the current module.\n\nUnlike leaf components, composite components do not have user-defined init or run_timestep functions; these are defined internally to iterate over constituent components and call the associated method on each.\n\n\n\n\n\n","category":"macro"},{"location":"ref/ref_API/#Mimi.MarginalModel","page":"Mimi API","title":"Mimi.MarginalModel","text":"MarginalModel\n\nA Mimi Model whose results are obtained by subtracting results of one base Model from those of another marginal Model that has a difference of delta.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.Model","page":"Mimi API","title":"Mimi.Model","text":"Model\n\nA user-facing API containing a ModelInstance (mi) and a ModelDef (md). This Model can be created with the optional keyword argument number_type indicating the default type of number used for the ModelDef.  If not specified the Model assumes a number_type of Float64.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.add_comp!","page":"Mimi API","title":"Mimi.add_comp!","text":"add_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_def::AbstractComponentDef,\n    comp_name::Symbol=comp_def.comp_id.comp_name;\n    first::NothingInt=nothing,\n    last::NothingInt=nothing,\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component comp_def to the composite component indicated by obj. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name. The optional  arguments first and last indicate the times bounding the run period for the given component,  which must be within the bounds of the model and if explicitly set are fixed.  These default  to flexibly changing with the model's :time dimension. \n\n\n\n\n\nadd_comp!(\n    obj::AbstractCompositeComponentDef,\n    comp_id::ComponentId,\n    comp_name::Symbol=comp_id.comp_name;\n    first::NothingInt=nothing,\n    last::NothingInt=nothing,\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component indicated by comp_id to the composite component indicated by obj. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional  arguments first and last indicate the times bounding the run period for the given component,  which must be within the bounds of the model and if explicitly set are fixed.  These default  to flexibly changing with the model's :time dimension.\n\n[Not yet implemented:] The optional argument rename can be a list of pairs indicating original_name => imported_name.\n\n\n\n\n\nadd_comp!(obj::AbstractCompositeComponentInstance, ci::AbstractComponentInstance)\n\nAdd the (leaf or composite) component ci to a composite's list of components.\n\n\n\n\n\nadd_comp!(\n    m::Model, comp_id::ComponentId, comp_name::Symbol=comp_id.comp_name;\n    first::NothingInt=nothing,\n    last::NothingInt=nothing,\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component indicated by comp_id to the model indicated by m. The component is added at the end of the list unless one of the keywords before or after is specified. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name. The optional  arguments first and last indicate the times bounding the run period for the given component,  which must be within the bounds of the model and if explicitly set are fixed.  These default  to flexibly changing with the model's :time dimension.\n\n\n\n\n\nadd_comp!(\n    m::Model, comp_def::AbstractComponentDef, comp_name::Symbol=comp_id.comp_name;\n    first::NothingInt=nothing,\n    last::NothingInt=nothing,\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    rename::NothingPairList=nothing\n)\n\nAdd the component comp_def to the model indicated by m. The component is added at the end of the list unless one of the keywords, first, last, before, after. Note that a copy of comp_id is made in the composite and assigned the give name. The optional argument rename can be a list of pairs indicating original_name => imported_name. The optional  arguments first and last indicate the times bounding the run period for the given component,  which must be within the bounds of the model and if explicitly set are fixed.  These default  to flexibly changing with the model's :time dimension.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.add_shared_param!","page":"Mimi API","title":"Mimi.add_shared_param!","text":"add_shared_param!(md::ModelDef, name::Symbol, value::Any; dims::Array{Symbol}=Symbol[])\n\nUser-facing API function to add a shared parameter to Model Def md with name name and value value, and an array of dimension names dims which dfaults to  an empty vector.  The is_shared attribute of the added Model Parameter will be true.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels. Optional keyword argument datatype allows user to specify a datatype to use for the shared model parameter.\n\n\n\n\n\nadd_shared_param!(m::Model, name::Symbol, value::Any; dims::Array{Symbol}=Symbol[], datatype::DataType=Nothing)\n\nUser-facing API function to add a shared parameter to Model m with name name and value value, and an array of dimension names dims which dfaults to  an empty vector.  The is_shared attribute of the added Model Parameter will be true.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.  This must be included if the value is not a scalar, and defaults to an empty vector. Optional keyword argument datatype allows user to specify a datatype to use for the shared model parameter.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.connect_param!","page":"Mimi API","title":"Mimi.connect_param!","text":"connect_param!(obj::AbstractCompositeComponentDef, comp_name::Symbol, param_name::Symbol, model_param_name::Symbol;\n               check_attributes::Bool=true, ignoreunits::Bool=false))\n\nConnect a parameter param_name in the component comp_name of composite obj to the model parameter model_param_name.\n\n\n\n\n\nconnect_param!(obj::AbstractCompositeComponentDef, comp_def::AbstractComponentDef,\n                param_name::Symbol, model_param_name::Symbol; check_attributes::Bool=true,\n                ignoreunits::Bool = false)\n\nConnect a parameter param_name in the component comp_def of composite obj to the model parameter model_param_name.\n\n\n\n\n\nconnect_param!(obj::AbstractCompositeComponentDef,\n    dst::Pair{Symbol, Symbol}, src::Pair{Symbol, Symbol},\n    backup::Union{Nothing, Array}=nothing;\n    ignoreunits::Bool=false, backup_offset::Union{Nothing, Int} = nothing)\n\nBind the parameter dst[2] of one component dst[1] of composite obj to a variable src[2] in another component src[1] of the same composite using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The backup_offset argument, which is only valid  when backup data has been set, indicates that the backup data should be used for a specified number of timesteps after the source component begins. ie. the value would be  1 if the destination componentm parameter should only use the source component  data for the second timestep and beyond.\n\n\n\n\n\nconnect_param!(dst::ComponentReference, dst_name::Symbol, src::ComponentReference, src_name::Symbol)\n\nConnect two components as connect_param!(dst, dst_name, src, src_name).\n\n\n\n\n\nconnect_param!(dst::ComponentReference, src::ComponentReference, name::Symbol)\n\nConnect two components with the same name as connect_param!(dst, src, name).\n\n\n\n\n\nconnect_param!(m::Model, dst_comp_name::Symbol, dst_par_name::Symbol, \n                src_comp_name::Symbol, src_var_name::Symbol, \n                backup::Union{Nothing, Array}=nothing; ignoreunits::Bool=false, \n                backup_offset::Union{Int, Nothing}=nothing)\n\nBind the parameter dst_par_name of one component dst_comp_name of model m to a variable src_var_name in another component src_comp_name of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The backup_offset argument, which is only valid  when backup data has been set, indicates that the backup data should be used for a specified number of timesteps after the source component begins. ie. the value would be  1 if the destination componentm parameter should only use the source component  data for the second timestep and beyond.\n\n\n\n\n\nconnect_param!(m::Model, comp_name::Symbol, param_name::Symbol, model_param_name::Symbol;\n               check_attributes::Bool=true, ignoreunits::Bool=false))\n\nConnect a parameter param_name in the component comp_name of composite obj to the model parameter model_param_name.\n\n\n\n\n\nconnect_param!(m::Model, dst::Pair{Symbol, Symbol}, src::Pair{Symbol, Symbol}, backup::Array; ignoreunits::Bool=false)\n\nBind the parameter dst[2] of one component dst[1] of model m to a variable src[2] in another component src[1] of the same model using backup to provide default values and the ignoreunits flag to indicate the need to check match units between the two.  The backup_offset argument, which is only valid  when backup data has been set, indicates that the backup data should be used for a specified number of timesteps after the source component begins. ie. the value would be  1 if the destination componentm parameter should only use the source component  data for the second timestep and beyond.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.create_marginal_model","page":"Mimi API","title":"Mimi.create_marginal_model","text":"create_marginal_model(base::Model, delta::Float64=1.0)\n\nCreate a MarginalModel where base is the baseline model and delta is the difference used to create the marginal model.  Return the resulting MarginaModel which shares the internal ModelDef between the base and marginal.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.delete_param!","page":"Mimi API","title":"Mimi.delete_param!","text":"delete_param!(md::ModelDef, model_param_name::Symbol)\n\nDelete model_param_name from md's list of model parameters, and also  remove all external parameters connections that were connected to model_param_name.\n\n\n\n\n\ndelete_param!(m::Model, model_param_name::Symbol)\n\nDelete model_param_name from a model m's ModelDef's list of model parameters, and also remove all external parameters connections that were connected to model_param_name.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.dim_count","page":"Mimi API","title":"Mimi.dim_count","text":"dim_count(def::AbstractDatumDef)\n\nReturn number of dimensions in def.\n\n\n\n\n\ndim_count(mi::ModelInstance, dim_name::Symbol)\n\nReturn the size of index dim_name in model instance mi.\n\n\n\n\n\ndim_count(m::Model, dim_name::Symbol)\n\nReturn the size of index dim_name in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.dim_keys","page":"Mimi API","title":"Mimi.dim_keys","text":"dim_keys(m::Model, dim_name::Symbol)\n\nReturn keys for dimension dim-name in model m.\n\n\n\n\n\ndim_keys(mi::ModelInstance, dim_name::Symbol)\n\nReturn keys for dimension dim-name in model instance mi.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.dim_key_dict","page":"Mimi API","title":"Mimi.dim_key_dict","text":"dim_key_dict(m::Model)\n\nReturn a dict of dimension keys for all dimensions in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.disconnect_param!","page":"Mimi API","title":"Mimi.disconnect_param!","text":"disconnect_param!(obj::AbstractCompositeComponentDef, comp_def::AbstractComponentDef, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def which must be a direct subcomponent of composite obj.\n\n\n\n\n\ndisconnect_param!(obj::AbstractCompositeComponentDef, comp_name::Symbol, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def which must be a direct subcomponent of composite obj.\n\n\n\n\n\ndisconnect_param!(m::Model, comp_name::Symbol, param_name::Symbol)\n\nRemove any parameter connections for a given parameter param_name in a given component comp_def in model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.explore","page":"Mimi API","title":"Mimi.explore","text":"explore(m::Model)\n\nProduce a UI to explore the parameters and variables of Model m in an independent window.\n\n\n\n\n\nexplore(mi::ModelInstance)\n\nProduce a UI to explore the parameters and variables of ModelInstance mi in an independent window.\n\n\n\n\n\nexplore(sim_inst::SimulationInstance; title=\"Electron\", model_index::Int = 1, scen_name::Union{Nothing, String} = nothing, results_output_dir::Union{Nothing, String} = nothing)\n\nProduce a UI to explore the output distributions of the saved variables in SimulationInstance sim for results of model model_index and scenario with the name scen_name in a Window with title title. The optional arguments default to a model_index of 1, a scen_name of nothing  assuming there is no secenario dimension, and a window with title Electron.   The results_output_dir keyword argument refers to the main output directory as provided to run,  where all subdirectories are held. If provided, results are assumed to be stored there, otherwise it is  assumed that results are held in results.sim and not  in an output folder.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.getdataframe","page":"Mimi API","title":"Mimi.getdataframe","text":"getdataframe(m::AbstractModel, comp_name::Symbol, pairs::Pair{Symbol, Symbol}...)\n\nReturn a DataFrame with values for the given variables or parameters of model m indicated by pairs, where each pair is of the form comp_name => item_name. If more than one pair is provided, all must refer to items with the same dimensions, which are used to join the respective item values.\n\n\n\n\n\ngetdataframe(m::AbstractModel, pair::Pair{Symbol, NTuple{N, Symbol}})\n\nReturn a DataFrame with values for the given variables or parameters  indicated by pairs, where each pair is of the form comp_name => item_name. If more than one pair is provided, all must refer to items with the same dimensions, which are used to join the respective item values.\n\n\n\n\n\ngetdataframe(m::AbstractModel, comp_name::Symbol, item_name::Symbol)\n\nReturn the values for variable or parameter item_name in comp_name of  model m as a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.gettime","page":"Mimi API","title":"Mimi.gettime","text":"gettime(ts::FixedTimestep)\n\nReturn the time (year) represented by Timestep ts \n\n\n\n\n\ngettime(ts::VariableTimestep)\n\nReturn the time (year) represented by Timestep ts \n\n\n\n\n\ngettime(c::Clock)\n\nReturn the time of the timestep held by the c clock.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.get_param_value","page":"Mimi API","title":"Mimi.get_param_value","text":"get_param_value(ci::AbstractComponentInstance, name::Symbol)\n\nReturn the value of parameter name in (leaf or composite) component ci.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.get_var_value","page":"Mimi API","title":"Mimi.get_var_value","text":"get_var_value(ci::AbstractComponentInstance, name::Symbol)\n\nReturn the value of variable name in component ci.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.hasvalue","page":"Mimi API","title":"Mimi.hasvalue","text":"hasvalue(arr::TimestepArray, ts::FixedTimestep)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::VariableTimestep)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::FixedTimestep, idxs::Int...)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts within indices idxs. Used when Array and Timestep have different FIRST, validating all dimensions.\n\n\n\n\n\nhasvalue(arr::TimestepArray, ts::VariableTimestep, idxs::Int...)\n\nReturn true or false, true if the TimestepArray arr contains the Timestep ts within indices idxs. Used when Array and Timestep have different TIMES, validating all dimensions.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.is_first","page":"Mimi API","title":"Mimi.is_first","text":"is_first(ts::AbstractTimestep)\n\nReturn true or false, true if ts is the first timestep to be run.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.is_last","page":"Mimi API","title":"Mimi.is_last","text":"is_last(ts::FixedTimestep)\n\nReturn true or false, true if ts is the last timestep to be run.\n\n\n\n\n\nis_last(ts::VariableTimestep)\n\nReturn true or false, true if ts is the last timestep to be run.  Note that you may run next_timestep on ts, as ths final timestep has not been run through yet.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.is_time","page":"Mimi API","title":"Mimi.is_time","text":"is_time(ts::AbstractTimestep, t::Int)\n\nDeprecated function to return true or false, true if the current time (year) for ts is t\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.is_timestep","page":"Mimi API","title":"Mimi.is_timestep","text":"is_timestep(ts::AbstractTimestep, t::Int)\n\nDeprecated function to return true or false, true if ts timestep is step t.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.modeldef","page":"Mimi API","title":"Mimi.modeldef","text":"modeldef(mi)\n\nReturn the ModelDef contained by ModelInstance mi.\n\n\n\n\n\nmodeldef(m)\n\nReturn the ModelDef contained by Model m.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Base.nameof","page":"Mimi API","title":"Base.nameof","text":"nameof(obj::NamedDef) = obj.name\n\nReturn the name of def.  NamedDefs include DatumDef, ComponentDef, and CompositeComponentDef\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.parameter_dimensions","page":"Mimi API","title":"Mimi.parameter_dimensions","text":"parameter_dimensions(obj::AbstractComponentDef, param_name::Symbol)\n\nReturn the names of the dimensions of parameter param_name exposed in the component definition indicated by obj.\n\n\n\n\n\nparameter_dimensions(obj::AbstractComponentDef, comp_name::Symbol, param_name::Symbol)\n\nReturn the names of the dimensions of parameter param_name in component comp_name, which is exposed in composite component definition indicated byobj.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.parameter_names","page":"Mimi API","title":"Mimi.parameter_names","text":"parameter_names(md::ModelDef, comp_name::Symbol)\n\nReturn a list of all parameter names for a given component comp_name in a model def md.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Base.replace!","page":"Mimi API","title":"Base.replace!","text":"replace!(\n    m::Model,\n    old_new::Pair{Symbol, ComponentDef},\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    reconnect::Bool=true\n)\n\nFor the pair comp_name => comp_def in old_new, replace the component with name comp_name in  the model m with the new component specified by comp_def. The new component is added  in the same position as the old component, unless one of the keywords before or after is  specified for a different position. The optional boolean argument reconnect with default value  true indicates whether the existing parameter connections should be maintained in the new  component. Returns a ComponentReference for the added component.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.replace_comp!","page":"Mimi API","title":"Mimi.replace_comp!","text":"replace_comp!(\n    m::Model, comp_def::ComponentDef, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    reconnect::Bool=true\n)\n\nDeprecated function for replacing the component with name comp_name in model m with the  new component specified by comp_def. Use the following syntax instead:\n\nreplace!(m, comp_name => comp_def; kwargs...)\n\nSee docstring for replace! for further description of available functionality.\n\n\n\n\n\nreplace_comp!(\n    m::Model, comp_id::ComponentId, comp_name::Symbol=comp_id.comp_name;\n    before::NothingSymbol=nothing,\n    after::NothingSymbol=nothing,\n    reconnect::Bool=true\n)\n\nDeprecated function for replacing the component with name comp_name in model m with the  new component specified by comp_id. Use the following syntax instead:\n\nreplace!(m, comp_name => Mimi.compdef(comp_id); kwargs...)\n\nSee docstring for replace! for further description of available functionality.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Base.run","page":"Mimi API","title":"Base.run","text":"Base.run(mm::MarginalModel; ntimesteps::Int=typemax(Int))\n\nRun the marginal model mm once with ntimesteps.\n\n\n\n\n\nBase.run(mi::ModelInstance, ntimesteps::Int=typemax(Int),\n        dimkeys::Union{Nothing, Dict{Symbol, Vector{T} where T <: DimensionKeyTypes}}=nothing)\n\nRun the ModelInstance mi once with ntimesteps and dimension keys dimkeys.\n\n\n\n\n\nBase.run(m::Model; ntimesteps::Int=typemax(Int), rebuild::Bool=false,\n        dim_keys::Union{Nothing, Dict{Symbol, Vector{T} where T <: DimensionKeyTypes}}=nothing)\n\nRun model m once.\n\n\n\n\n\nBase.run(sim_def::SimulationDef{T}, \n        models::Union{Vector{M}, AbstractModel}, \n        samplesize::Int;\n        ntimesteps::Int=typemax(Int), \n        trials_output_filename::Union{Nothing, AbstractString}=nothing, \n        results_output_dir::Union{Nothing, AbstractString}=nothing, \n        pre_trial_func::Union{Nothing, Function}=nothing, \n        post_trial_func::Union{Nothing, Function}=nothing,\n        scenario_func::Union{Nothing, Function}=nothing,\n        scenario_placement::ScenarioLoopPlacement=OUTER,\n        scenario_args=nothing,\n        results_in_memory::Bool=true) where {T <: AbstractSimulationData, M <: AbstractModel}\n\nRun the simulation definition sim_def for the models using samplesize samples.\n\nOptionally run the models for ntimesteps, if specified,  else to the maximum defined time period. Note that trial data are applied to all the  associated models even when running only a portion of them.   \n\nIf provided, the generated trials and results will be saved in the indicated  trials_output_filename and results_output_dir respectively. If results_in_memory is set to false, then results will be cleared from memory and only stored in the results_output_dir.\n\nIf pre_trial_func or post_trial_func are defined, the designated functions are called  just before or after (respectively) running a trial. The functions must have the signature:\n\nfn(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)\n\nwhere tup is a tuple of scenario arguments representing one element in the cross-product of all scenario value vectors. In situations in which you want the simulation loop to run only some of the models, the remainder of the runs can be handled using a pre_trial_func or post_trial_func.\n\nIf provided, scenario_args must be a Vector{Pair}, where each Pair is a symbol and a  Vector of arbitrary values that will be meaningful to scenario_func, which must have the signature:\n\nscenario_func(sim_inst::SimulationInstance, tup::Tuple)\n\nBy default, the scenario loop encloses the simulation loop, but the scenario loop can be placed inside the simulation loop by specifying scenario_placement=INNER. When INNER  is specified, the scenario_func is called after any pre_trial_func but before the model is run.\n\nReturns the type SimulationInstance that contains a copy of the original SimulationDef, along with mutated information about trials, in addition to the model list and  results information.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.set_dimension!","page":"Mimi API","title":"Mimi.set_dimension!","text":"set_dimension!(ccd::CompositeComponentDef, name::Symbol, keys::Union{Int, Vector, Tuple, AbstractRange})\n\nSet the values of ccd dimension name to integers 1 through count, if keys is an integer; or to the values in the vector or range if keys is either of those types.\n\n\n\n\n\nset_dimension!(obj::AbstractComponentDef, name::Symbol, dim::Dimension)\n\nSet the dimension name in obj to dim.\n\n\n\n\n\nset_dimension!(m::Model, name::Symbol, keys::Union{Vector, Tuple, AbstractRange})\n\nSet the values of m dimension name to integers 1 through count, if keysis an integer; or to the values in the vector or range ifkeys`` is either of those types.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.set_leftover_params!","page":"Mimi API","title":"Mimi.set_leftover_params!","text":"set_leftover_params!(md::ModelDef, parameters::Dict)\n\nSet all of the parameters in ModelDef md that don't have a value and are not connected to some other component to a value from a dictionary parameters. This method assumes the dictionary keys are Symbols (or convertible into Symbols ie. Strings) that  match the names of unset parameters in the model. All resulting connected model  parameters will be shared model parameters.\n\nNote that this function set_leftover_params! has been deprecated, and uses should be transitioned to usingupdateleftoverparams!` with keys specific to component-parameter  pairs i.e. (compname, paramname) => value in the dictionary.\n\n\n\n\n\nset_leftover_params!(m::Model, parameters::Dict)\n\nSet all of the parameters in Model m that don't have a value and are not connected to some other component to a value from a dictionary parameters. This method assumes the dictionary keys are strings (or convertible into Strings ie. Symbols) that  match the names of unset parameters in the model, and all resulting new model  parameters will be shared parameters.\n\nNote that this function set_leftover_params! has been deprecated, and uses should be transitioned to usingupdateleftoverparams!` with keys specific to component-parameter  pairs i.e. (compname, paramname) => value in the dictionary.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.set_param!","page":"Mimi API","title":"Mimi.set_param!","text":"set_param!(md::ModelDef, comp_name::Symbol,\n           value_dict::Dict{Symbol, Any}, param_names)\n\nCall set_param!() for each name in param_names, retrieving the corresponding value from value_dict[param_name].\n\n\n\n\n\nset_param!(md::ModelDef, comp_name::Symbol, param_name::Symbol, value; dims=nothing)\n\nSet the value of parameter param_name in component comp_name of Model Def md  to value.  This will create a shared model parameter with name param_name  and connect comp_name's parameter param_name to it.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(md::ModelDef, comp_name::Symbol, param_name::Symbol, model_param_name::Symbol, \n            value; dims=nothing)\n\nSet the value of parameter param_name in component comp_name of Model Def md  to value.  This will create a shared model parameter with name model_param_name  and connect comp_name's parameter param_name to it.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(md::ModelDef, comp_def::AbstractComponentDef, param_name::Symbol, \n            model_param_name::Symbol, value; dims=nothing)\n\nSet the value of parameter param_name in component comp_def of Model Def md  to value.  This will create a shared model parameter with name model_param_name  and connect comp_name's parameter param_name to it.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(md::ModelDef, param_name::Symbol, value; dims=nothing)\n\nSet the value of parameter param_name in all components of the Model Defmdthat have a parameter of the specified name tovalue.  This will create a shared model parameter with nameparam_name` and connect all component parameters with that name to it.\n\nThe value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(ref::ComponentReference, name::Symbol, value)\n\nSet a component parameter as set_param!(reference, name, value). This creates a unique name :compname_paramname in the model's model parameter list,  and sets the parameter only in the referenced component to that value.\n\n\n\n\n\nset_param!(m::Model, comp_name::Symbol, param_name::Symbol, value; dims=nothing)\n\nSet the parameter of a component comp_name in a model m to a given value. The value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(m::Model, comp_name::Symbol, param_name::Symbol, model_param_name::Symbol, value; dims=nothing)\n\nSet the parameter param_name of a component comp_name in a model m to a given value,  storing the value in the model's parameter list by the provided name model_param_name. The value can by a scalar, an array, or a NamedAray. Optional keyword argument 'dims' is a list of the dimension names of the provided data, and will be used to check that they match the model's index labels.\n\n\n\n\n\nset_param!(m::Model, param_name::Symbol, value; dims=nothing)\n\nSet the value of a parameter in all components of the model that have a parameter of  the specified name.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.TimestepIndex","page":"Mimi API","title":"Mimi.TimestepIndex","text":"TimestepIndex\n\nA user-facing type used to index into a TimestepArray in run_timestep functions, containing an Int index that indicates the position in the array in terms of timesteps.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.TimestepValue","page":"Mimi API","title":"Mimi.TimestepValue","text":"TimestepValue\n\nA user-facing type used to index into a TimestepArray in run_timestep functions, containing a value of the same Type as the times in the TimstepArray which is used to index into the array at that position, with an optional Int offset in terms of timesteps.\n\n\n\n\n\n","category":"type"},{"location":"ref/ref_API/#Mimi.update_param!","page":"Mimi API","title":"Mimi.update_param!","text":"update_param!(obj::AbstractCompositeComponentDef, name::Symbol, value; update_timesteps = nothing)\n\nUpdate the value of a model parameter in composite obj, referenced by name. The update_timesteps keyword argument is deprecated, we keep it here  just to provide warnings.\n\n\n\n\n\nupdate_param!(mi::ModelInstance, name::Symbol, value)\n\nUpdate the value of a model parameter in ModelInstance mi, referenced by name.  This is an UNSAFE update as it does not dirty the model, and should  be used carefully and specifically for things like our MCS work.\n\n\n\n\n\nupdate_param!(mi::ModelInstance, comp_name::Symbol, param_name::Symbol, value)\n\nUpdate the value of a model parameter in ModelInstance mi, connected to  component comp_name's parameter param_name. This is an UNSAFE updat as it does  not dirty the model, and should  be used carefully and specifically for things like  our MCS work.\n\n\n\n\n\nupdate_param!(md::ModelDef, comp_name::Symbol, param_name::Symbol, value)\n\nUpdate the value of the unshared model parameter in Model Def md connected to component  comp_name's parameter param_name. \n\n\n\n\n\nupdate_param!(ref::ComponentReference, name::Symbol, value)\n\nUpdate a component parameter as update_param!(reference, name, value). This uses the unique name :compname_paramname in the model's model parameter list,  and updates the parameter only in the referenced component to that value.\n\n\n\n\n\nupdate_param!(m::Model, name::Symbol, value; update_timesteps = nothing)\n\nUpdate the value of an model parameter in model m, referenced by name. The update_timesteps keyword argument is deprecated, we keep it here  just to provide warnings.\n\n\n\n\n\nupdate_param!(m::Model, comp_name::Symbol, param_name::Symbol, value)\n\nUpdate the value of the unshared model parameter in Model m's Model Def connected to component comp_name's parameter param_name. \n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.update_params!","page":"Mimi API","title":"Mimi.update_params!","text":"update_params!(obj::AbstractCompositeComponentDef, parameters::Dict; update_timesteps = nothing)\n\nFor each (k, v) in the provided parameters dictionary, update_param! is called to update the model parameter identified by k to value v.\n\nFor updating unshared parameters, each key k must be a Tuple matching the name of a  component in obj and the name of an parameter in that component.\n\nFor updating shared parameters, each key k must be a symbol or convert to a symbol  matching the name of a shared model parameter that already exists in the model.\n\n\n\n\n\nupdate_params!(m::Model, parameters::Dict; update_timesteps = nothing)\n\nFor each (k, v) in the provided parameters dictionary, update_param! is called to update the model parameter identified by k to value v.\n\nFor updating unshared parameters, each key k must be a Tuple matching the name of a  component in obj and the name of an parameter in that component.\n\nFor updating shared parameters, each key k must be a symbol or convert to a symbol  matching the name of a shared model parameter that already exists in the model.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.update_leftover_params!","page":"Mimi API","title":"Mimi.update_leftover_params!","text":"update_leftover_params!(md::ModelDef, parameters::Dict)\n\nUpdate all of the parameters in ModelDef md that don't have a value and are not connected to some other component to a value from a dictionary parameters. This method assumes the dictionary keys are Tuples of Symbols (or convertible to Symbols ie. Strings)  of (compname, paramname) that match the component-parameter pair of  unset parameters in the model.  All resulting connected model parameters will be  unshared model parameters.\n\n\n\n\n\nupdate_leftover_params!(m::Model, parameters::Dict)\n\nUpdate all of the parameters in Model m that don't have a value and are not connected to some other component to a value from a dictionary parameters. This method assumes the dictionary keys are Tuples of Symbols (or convertible to Symbols ie. Strings)  of (compname, paramname) that match the component-parameter pair of  unset parameters in the model.  All resulting connected model parameters will be  unshared model parameters.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.variable_dimensions","page":"Mimi API","title":"Mimi.variable_dimensions","text":"variable_dimensions(obj::AbstractCompositeComponentDef, comp_path::ComponentPath, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated byobj along the component path comp_path. The comp_path is of type Mimi.ComponentPath with the single field being an NTuple of symbols describing the relative (to a composite) or absolute (relative to ModelDef) path through composite nodes to specific composite or leaf node.\n\n\n\n\n\nvariable_dimensions(obj::AbstractCompositeComponentDef, comp::Symbol, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated by obj for the component comp, which exists in a flat model.\n\n\n\n\n\nvariable_dimensions(obj::AbstractCompositeComponentDef, comp::Symbol, var_name::Symbol)\n\nReturn the names of the dimensions of variable var_name exposed in the composite component definition indicated by obj along the component path comp_path. The comp_path is a tuple of symbols describing the relative (to a composite) or absolute (relative to ModelDef) path through composite nodes to specific composite or leaf node.\n\n\n\n\n\nvariable_dimensions(obj::AbstractComponentDef, name::Symbol)\n\nReturn the names of the dimensions of variable name exposed in the component definition indicated by obj.\n\n\n\n\n\n","category":"function"},{"location":"ref/ref_API/#Mimi.variable_names","page":"Mimi API","title":"Mimi.variable_names","text":"variable_names(md::AbstractCompositeComponentDef, comp_name::Symbol)\n\nReturn a list of all variable names for a given component comp_name in a model def md.\n\n\n\n\n\nvariable_names(comp_def::AbstractComponentDef)\n\nReturn a list of all variable names for a given component comp_def.\n\n\n\n\n\n","category":"function"},{"location":"howto/howto_4/#How-to-Guide-4:-Work-with-Timesteps-1","page":"4 Timesteps","title":"How-to Guide 4: Work with Timesteps","text":"","category":"section"},{"location":"howto/howto_4/#Timesteps-and-Available-Functions-1","page":"4 Timesteps","title":"Timesteps and Available Functions","text":"","category":"section"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"An AbstractTimestep i.e. a FixedTimestep or a VariableTimestep is a type defined within Mimi in \"src/time.jl\". It is used to represent and keep track of time indices when running a model.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"In the run_timestep functions which the user defines, it may be useful to use any of the following functions, where t is an AbstractTimestep object:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"is_first(t) # returns true or false, true if t is the first timestep to be run for the respective component\nis_last(t) # returns true or false, true if t is the last timestep to be run for the respective component\ngettime(t) # returns the year represented by timestep t","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"There are also two helper types TimestepValue and TimestepIndex that can be used with comparison operators (==, <, and >) to check whether an AbstractTimestep t during the run_timestep function corresponds with a certain year or index number. For example:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"if t > TimestepValue(2020)\n  # run this code only for timesteps after the year 2020\nend\n\nif t == TimestepIndex(3)\n  # run this code only during the third timestep\nend","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"See below for further discussion of the TimestepValue and TimestepIndex objects and how they should be used.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"The API details for AbstractTimestep object t are as follows:","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"you may index into a variable or parameter with [t] or [t +/- x] as usual\nto access the time value of t (currently a year) as a Number, use gettime(t)\nuseful functions for commonly used conditionals are is_first(t) and is_last(t)\nto access the index value of t as a Number representing the position in the time array, use t.t.  Users are encouraged to avoid this access, and instead use comparisons with TimestepIndex objects to check if an AbstractTimestep t corresponds with a specific index number, as described above.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"Indexing into a variable or parameter's time dimension with an Integer is deprecated and will soon error. Instead, users should take advantage of the TimestepIndex and TimestepValue types. For examples we will refer back to our component definition above, and repeated below.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"@defcomp MyComponentName begin\n  regions = Index()\n\n  A = Variable(index = [time])\n  B = Variable(index = [time, regions])\n\n  c = Parameter()\n  d = Parameter(index = [time])\n  e = Parameter(index = [time, regions])\n  f = Parameter(index = [regions])\n\n  function run_timestep(p, v, d, t)\n    v.A[t] = p.c + p.d[t]\n    for r in d.regions\n      v.B[t, r] = p.f[r] * p.e[t, r]\n    end\n  end\n\nend","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"TimestepIndex has one field, index, which refers to the absolute index in the parameter or variable array's time dimension. Thus, constructing a TimestepIndex is done by simply writing TimestepIndex(index::Int). Looking back at our original component example, one could modify the first line of run_timestep to always refer to the first timestep of p.d with the following. One may index into the time dimension with a single TimestepIndex, or an Array of them.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"v.A[t] = p.c + p.d[TimestepIndex(1)]","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"TimestepValue has two fields, value and offset, referring to the value within the time dimension and an optional offset from that value. Thus, constructing a TimestepValue is done either by writing TimestepValue(value), with an implied offset of 0, or TimestepValue(value, offset = i::Int), with an explicit offset of i. One may index into the time dimension with a single TimestepValue, or an Array of them. For example, you can use a TimestepValue to keep track of a baseline year.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"v.A[t] = p.c + p.d[TimestepValue(2000)]","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"You may also use shorthand to create arrays of TimestepIndex using Colon syntax.","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"TimestepIndex(1):TimestepIndex(10) # implicit step size of 1\nTimestepIndex(1):2:TimestepIndex(10) # explicit step of type Int ","category":"page"},{"location":"howto/howto_4/#","page":"4 Timesteps","title":"4 Timesteps","text":"Both TimestepIndex and TimestepArray have methods to support addition and subtraction of integers.  Note that the addition or subtraction is relative to the definition of the time dimension, so while TimestepIndex(1) + 1 == TimestepIndex(2), TimestepValue(2000) + 1 could be equivalent to TimestepValue(2001) if 2001 is the next year in the time dimension, or TimestepValue(2005) if the array has a step size of 5. Hence adding or subtracting is relative to the definition of the time dimension. ","category":"page"},{"location":"howto/howto_2/#How-to-Guide-2:-View-and-Explore-Model-Results-1","page":"2 Explore Results","title":"How-to Guide 2: View and Explore Model Results","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"This guide show show to access the numerical values of your results in a usable format, and also how to plot your results.","category":"page"},{"location":"howto/howto_2/#Accessing-Results-1","page":"2 Explore Results","title":"Accessing Results","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"After a model has been run, you can access the results (the calculated variable values in each component) in a few different ways. Note that if you have used composite components and wish to access results deeper than the the parameters and variables available in your top-level components you may need the special syntax in the Composite Component Details subsection below.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"You can use the getindex syntax as follows:","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"m[:ComponentName, :VariableName] # returns the whole array of values\nm[:ComponentName, :VariableName][100] # returns just the 100th value","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Indexing into a model with the name of the component and variable will return an array with values from each timestep. You can index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is two-dimensional, then a 2-D array will be returned.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"You can also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this is:","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"getdataframe(m, :ComponentName=>:Variable) # request one variable from one component\ngetdataframe(m, :ComponentName=>(:Variable1, :Variable2)) # request multiple variables from the same component\ngetdataframe(m, :Component1=>:Var1, :Component2=>:Var2) # request variables from different components","category":"page"},{"location":"howto/howto_2/#Composite-Component-Details-1","page":"2 Explore Results","title":"Composite Component Details","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"[TODO]","category":"page"},{"location":"howto/howto_2/#Plotting-and-the-Explorer-UI-1","page":"2 Explore Results","title":"Plotting and the Explorer UI","text":"","category":"section"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Mimi provides support for plotting using VegaLite and VegaLite.jl.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Plotting support is provided by the Explorer UI, rooted in VegaLite.  The explore function allows the user to view and explore the variables and parameters of a model run.  The explorer can be used in two primary ways.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"In order to invoke the explorer UI and explore all of the variables and parameters in a model, simply call the function explore with the model run as the required argument as shown below.  This will produce a new browser window containing a selectable list of parameters and variables, organized by component, each of which produces a graphic.  The exception here being that if the parameter or variable is a single scalar value, the value will appear alongside the name in the left-hand list.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"run(m)\nexplore(m)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"(Image: Explorer Model Example)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Alternatively, in order to view just one parameter or variable, call the (unexported) function plot as below to return a plot object and automatically display the plot in a viewer, assuming plot is the last command executed.  Note that plot is not exported in order to avoid namespace conflicts, so needs to be called with Mimi.plot or a user may import it if desired. This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved as PNG, SVG, PDF and EPS files. You may save a plot using the save function.  ","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"Note that saving an interactive plot in a non-interactive file format, such as .pdf or .svg will result in a warning WARN Can not resolve event source: window, but the plot will be saved as a static image. If you wish to preserve interactive capabilities, you may save it using the .vegalite file extension. If you then open this file in Jupyter lab, the interactive aspects will be preserved.","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"using VegaLite\nrun(m)\np = Mimi.plot(m, :ComponentName, :ParameterName)\nsave(\"figure.svg\", p)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"(Image: Plot Model Example)","category":"page"},{"location":"howto/howto_2/#","page":"2 Explore Results","title":"2 Explore Results","text":"These two functions, explore and plot also have methods applicable to the sensitivity analysis support described in the next section. Details can be found in the sensitivity analysis how-to guide How-to Guide 3: Conduct Sensitivity Analysis as well as Tutorial 4: Sensitivity Analysis (SA) Support.","category":"page"},{"location":"ref/ref_structures_definitions/#Reference-Guide:-Structures-Definitions-1","page":"Structures: Definitions","title":"Reference Guide: Structures - Definitions","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#Model-Definition-1","page":"Structures: Definitions","title":"Model Definition","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Models are composed of two separate structures, which we refer to as the \"definition\" side and the \"instance\" or \"instantiated\" side. The definition side is operated on by the user via the @defcomp and @defcomposite macros, and the public API (add_comp!, update_param!, connect_param!, etc.).","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The instantiated model can be thought of as a \"compiled\" version of the model definition, with its data structures oriented toward run-time efficiency. It is constructed by Mimi in the build() function, which is called by the run() function.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The public API sets a flag whenever the user modifies the model definition, and the instance is rebuilt before it is run if the model definition has changed. Otherwise, the model instance is re-run.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The model definition is constructed from the following elements.","category":"page"},{"location":"ref/ref_structures_definitions/#Leaf-components-1","page":"Structures: Definitions","title":"Leaf components","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Leaf components are defined using the @defcomp macro which generates a component definition of the type ComponentDef which has the following fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# ComponentDef\nparent::Any\nname::Symbol\ncomp_id::Union{Nothing, ComponentId}   \ncomp_path::Union{Nothing, ComponentPath}\ndim_dict::OrderedDict{Symbol, Union{Nothing, Dimension}}\nnamespace::OrderedDict{Symbol, Any}       \nfirst::Union{Nothing, Int}\nlast::Union{Nothing, Int}\nis_uniform::Bool","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The namespace of a leaf component can hold ParameterDefs and VariableDefs, both which are subclasses of DatumDef (see below for more details on these types).","category":"page"},{"location":"ref/ref_structures_definitions/#Composite-components-1","page":"Structures: Definitions","title":"Composite components","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Composite components are defined using the @defcomposite macro which generates a composite component definition of the type CompositeComponentDef which has the following fields, in addition to the fields of a ComponentDef:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# CompositeComponentDef <: ComponentDef \ninternal_param_conns::Vector{InternalParameterConnection}   \nbackups::Vector{Symbol}","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The namespace of a composite component can hold CompositeParameterDefs andCompositeVariableDefs, as well as AbstractComponentDefs (which can be other leaf or composite component definitions).","category":"page"},{"location":"ref/ref_structures_definitions/#Datum-definitions-1","page":"Structures: Definitions","title":"Datum definitions","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Note: we use \"datum\" to refer collectively to parameters and variables. Parameters are values that are fed into a component, and variables are values calculated by a component's run_timestep function.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Datum are defined with the @defcomp and @defcomposite macros, and have the following fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# DatumDef\nname::Symbol\ncomp_path::Union{Nothing, ComponentPath}\ndatatype::DataType\ndim_names::Vector{Symbol}\ndescription::String\nunit::String","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The only difference between a ParameterDef and a VariableDef is that parameters can have default values.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# ParameterDef <: DatumDef\ndefault::Any\n\n# VariableDef <: DatumDef\n# (This class adds no new fields. It exists to differentiate variables from parameters.)","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"CompositeParameterDefs and CompositeVariableDefs are defined in the @defcomposite macro, and point to datum from their subcomponents. (Remember, composite components do not have run_timestep functions, so no values are actually calculated in a composite component.) Thus, CompositeParameterDefs and CompositeVariableDefs inherit all the fields from ParameterDefs and VariableDefs, and have an additional field to record which subcomponent(s)' datum they reference.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# CompositeParameterDef <: ParameterDef\nrefs::Vector{UnnamedReference}\n\n# CompositeVariableDef <: VariableDef\nref::UnnamedReference","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Note: a CompositeParameterDef can reference multiple subcomponents' parameters, but a CompositeVariableDef can only reference a variable from one subcomponent.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"The reference(s) stored in CompositeParameterDefs and CompositeVariableDefs are of type UnnamedReference, which has the following fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# UnnamedReference\ncomp_name::Symbol   # name of the referenced subcomponent\ndatum_name::Symbol  # name of the parameter or variable in the subcomponent's namespace","category":"page"},{"location":"ref/ref_structures_definitions/#ModelDef-1","page":"Structures: Definitions","title":"ModelDef","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"A ModelDef is a top-level composite that also stores model parameters and a list of model parameter connections. It contains the following additional fields:","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# ModelDef <: CompositeComponentDef\nexternal_param_conns::Vector{ExternalParameterConnection}\nmodel_params::Dict{Symbol, ModelParameter}\nnumber_type::DataType\ndirty::Bool","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"Note: a ModelDef's namespace will only hold AbstractComponentDefs. ","category":"page"},{"location":"ref/ref_structures_definitions/#Parameter-Connections-1","page":"Structures: Definitions","title":"Parameter Connections","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"InternalParameterConnection Internal parameters are defined by connecting a parameter in one component to a variable in another component. This struct holds the names and ComponentPaths of the parameter and variable, and other information such as the \"backup\" data source. At build time, internal parameter connections result in direct references from the parameter to the storage allocated for the variable.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"ExternalParameterConnection Values that are exogenous to the model are defined in model parameters whose values are assigned using the public API function update_param!(), or by setting default values in @defcomp or @defcomposite, in which case, the default values are assigned via an internal call to update_param!().","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"External connections are stored in the ModelDef, along with the actual ModelParameters, which may be scalar values or arrays, as described below.","category":"page"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"# AbstractConnection\n\n# InternalParameterConnection <: AbstractConnection\nsrc_comp_path::ComponentPath      \nsrc_var_name::Symbol\ndst_comp_path::ComponentPath\ndst_par_name::Symbol\nignoreunits::Bool\nbackup::Union{Symbol, Nothing} # a Symbol identifying the model param providing backup data, or nothing\nbackup_offset::Union{Int, Nothing}\n\n# ExternalParameterConnection  <: AbstractConnection\ncomp_path::ComponentPath\nparam_name::Symbol      # name of the parameter in the component\nmodel_param_name::Symbol  # name of the parameter stored in the model's model_params","category":"page"},{"location":"ref/ref_structures_definitions/#Model-parameters-1","page":"Structures: Definitions","title":"Model parameters","text":"","category":"section"},{"location":"ref/ref_structures_definitions/#","page":"Structures: Definitions","title":"Structures: Definitions","text":"ModelParameter This is an abstract type that is the supertype of both ScalarModelParameter{T} and ArrayModelParameter{T}. These two parameterized types are used to store values set for model parameters.","category":"page"},{"location":"tutorials/tutorial_6/#Tutorial-6:-Create-a-Model-Including-Composite-Components-1","page":"6 Create a Model with Composite Components","title":"Tutorial 6: Create a Model Including Composite Components","text":"","category":"section"},{"location":"tutorials/tutorial_6/#","page":"6 Create a Model with Composite Components","title":"6 Create a Model with Composite Components","text":"This tutorial walks through the steps to create a new model that uses composite components, a new feature of Mimi v1.0.0.","category":"page"},{"location":"tutorials/tutorial_6/#","page":"6 Create a Model with Composite Components","title":"6 Create a Model with Composite Components","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_6/#","page":"6 Create a Model with Composite Components","title":"6 Create a Model with Composite Components","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher","category":"page"},{"location":"tutorials/tutorial_6/#","page":"6 Create a Model with Composite Components","title":"6 Create a Model with Composite Components","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_main/#Tutorials-Introduction-1","page":"Tutorials Intro","title":"Tutorials Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"The following tutorials target Mimi users of different experience levels, starting with first-time users.  Before engaging with these tutorials, we recommend that users read the introductory Welcome to Mimi page. It will also be helpful to be comfortable with the basics of the Julia language, though expertise is not required.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"If you find a bug in these tutorials, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"tutorials/tutorial_main/#Available-Tutorials-1","page":"Tutorials Intro","title":"Available Tutorials","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 1: Install Mimi describes how to set up your system by installing julia, Mimi, and the Mimi registry.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 2: Run an Existing Model steps through the tasks to download, run, and view the results of a registered model such as FUND.  It should be usable for all users, including first-time users, and is a good place to start when learning to use Mimi.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 3: Modify an Existing Model builds on Tutorial 2, showing how to modify an existing model such as DICE.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 4: Create a Model takes a step beyond using registered models, explaining how to create a model from scratch.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 5: Monte Carlo Simulations and Sensitivity Analysis Support explores Mimi's Monte Carlo simulation and sensitivity analysis support, using both the simple multi-Region tutorial model and MimiDICE2010 examples.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 6: Create a Model Including Composite Components expands on Tutorial 4 and explains how to create a model from scratch including the use of composite components.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Tutorial 7: Couple Two Existing Models demonstrates how to couple together two models, both configured as packages, specifically in this case replacing (most of) the FUND model's climate module with the FAIR model.","category":"page"},{"location":"tutorials/tutorial_main/#Additional-Tutorals-1","page":"Tutorials Intro","title":"Additional Tutorals","text":"","category":"section"},{"location":"tutorials/tutorial_main/#AERE-Workshop-Tutorials:-1","page":"Tutorials Intro","title":"AERE Workshop Tutorials:","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"The Mimi developement team recently participated in the 2019 Association of Environmental and Resource Economists (AERE) summer conference during the pre-conference workshop on Advances in Integrated Assessment Models. This included both a presentation and a hands-on session demonstrating various use cases for Mimi. The Github repository here contains a) all slides from the workshop and b) all the code from the hands on sessions, which may be of interest to Mimi users. Importantly note that the linked code represents as a snapshot of Mimi at the time of the workshop, and will not be updated to reflect new changes.","category":"page"},{"location":"tutorials/tutorial_main/#Resources-for-the-Future-(RFF)-Webinar-1","page":"Tutorials Intro","title":"Resources for the Future (RFF) Webinar","text":"","category":"section"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"On February 10, 2021, Resources for the Future (RFF) held a live webinar for over 1,000 participants described on rff.org as follows:","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"\"Over the past four years, the Social Cost of Carbon Initiative at Resources for the Future (RFF) has been a key hub for SCC scholarship to implement the NAS recommendations. On February 10, 2021, RFF held a live webinar that highlighted the latest SCC-related research from RFF scholars and the Climate Impact Lab. The conversation also featured perspectives from decisionmakers using the SCC to inform policy and highlighted key considerations for the Biden administration’s near-term and final updates of the estimates.\"","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"This webinar highlighted Mimi as a \"free, open-source computing platform allows users to access, run, and modify the social cost of carbon (SCC) models used by the federal Interagency Working Group to estimate the SCC\", and was paired with the Social Cost of Carbon Computing Platform: Models from the Interagency Working Group post including an embedded video by Professor Anthoff.","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Links: ","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"RFF Mimi Post (with link to Mimi Demo )","category":"page"},{"location":"tutorials/tutorial_main/#","page":"Tutorials Intro","title":"Tutorials Intro","text":"Direct YouTube Link to Mimi Demo","category":"page"},{"location":"tutorials/tutorial_2/#Tutorial-2:-Run-an-Existing-Model-1","page":"2 Run an Existing Model","title":"Tutorial 2: Run an Existing Model","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"This tutorial walks through the steps to download, run, and view the output of an existing model.  There are several existing models publically available on Github, and for the purposes of this tutorial we will use The Climate Framework for Uncertainty, Negotiation and Distribution (FUND), available on Github here.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher\nconnection of your julia installation with the central Mimi registry of Mimi models","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_2/#Step-1.-Download-FUND-1","page":"2 Run an Existing Model","title":"Step 1. Download FUND","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"The first step in this process is downloading the FUND model, which is now made easy with the Mimi registry. Assuming you have already done the one-time run of the following command to connect your julia installation with the central Mimi registry of Mimi models, as instructed in the first tutorial,","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"you simply need to add the FUND model in the Pkg REPL with:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"pkg> add MimiFUND","category":"page"},{"location":"tutorials/tutorial_2/#Step-2.-Run-FUND-1","page":"2 Run an Existing Model","title":"Step 2. Run FUND","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"The next step is to run FUND. If you wish to first get more acquainted with the model itself, take a look at the provided online documentation.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Now open a julia REPL and type the following command to load the MimiFUND package into the current environment:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"using MimiFUND","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Now we can access the public API of FUND, including the function MimiFUND.get_model. This function returns a copy of the default FUND model. Here we will first get the model, and then use the run function to run it.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"m = MimiFUND.get_model()\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"These steps should be relatively consistent across models, where a repository for ModelX should contain a primary file ModelX.jl which exports, at minimum, a function named something like get_model or construct_model which returns a version of the model, and can allow for model customization within the call.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"In the MimiFUND package, the function get_model has the signature","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"get_model(; nsteps = default_nsteps, datadir = default_datadir, params = default_params)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Thus there are no required arguments, although the user can input nsteps to define the number of timesteps (years in this case) the model runs for, datadir to define the location of the input data, and params, a dictionary definining the parameters of the model.  For example, if you wish to run only the first 200 timesteps, you may use:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"using MimiFUND\nm = MimiFUND.get_model(nsteps = 200)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_2/#Step-3.-Access-Results:-Values-1","page":"2 Run an Existing Model","title":"Step 3. Access Results: Values","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"After the model has been run, you may access the results (the calculated variable values in each component) in a few different ways.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Start off by importing the Mimi package to your space with","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"using Mimi","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"First of all, you may use the getindex syntax as follows:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"m[:ComponentName, :VariableName] # returns the whole array of values\nm[:ComponentName, :VariableName][100] # returns just the 100th value\n","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Indexing into a model with the name of the component and variable will return an array with values from each timestep. You may index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is two-dimensional, then a 2-D array will be returned. For example, try taking a look at the income variable of the socioeconomic component of FUND using the code below:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"m[:socioeconomic, :income]\nm[:socioeconomic, :income][100]","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"You may also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this uses getdataframe as follows:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"getdataframe(m, :ComponentName=>:Variable) # request one variable from one component\ngetdataframe(m, :ComponentName=>(:Variable1, :Variable2)) # request multiple variables from the same component\ngetdataframe(m, :Component1=>:Var1, :Component2=>:Var2) # request variables from different components","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Try doing this for the income variable of the socioeconomic component using:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"getdataframe(m, :socioeconomic=>:income) # request one variable from one component\ngetdataframe(m, :socioeconomic=>:income)[1:16,:] # results for all regions in first year (1950)","category":"page"},{"location":"tutorials/tutorial_2/#Step-4.-Access-Results:-Plots-and-Graphs-1","page":"2 Run an Existing Model","title":"Step 4. Access Results: Plots and Graphs","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"After running the FUND model, you may also explore the results using plots and graphs.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Mimi provides support for plotting using VegaLite and VegaLite.jl within the Mimi Explorer UI.","category":"page"},{"location":"tutorials/tutorial_2/#Explore-1","page":"2 Run an Existing Model","title":"Explore","text":"","category":"section"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"If you wish to explore the results graphically, use the explorer UI. This functionality is described in more detail in the second how-to guide, How-to Guide 2: View and Explore Model Results. For now, however, you don't need this level of detail and can simply follow the steps below.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"To explore all variables and parameters of FUND in a dynamic UI app window, use the explore function called with the model as the required first argument.  The menu on the left hand side will list each element in a label formatted as component: variable/parameter.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"explore(m)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Alternatively, in order to view just one parameter or variable, call the function explore as below to return a plot object and automatically display the plot in a viewer, assuming explore is the last command executed.  This call will return the type VegaLite.VLSpec, which you may interact with using the API described in the VegaLite.jl documentation.  For example, VegaLite.jl plots can be saved as PNG, SVG, PDF and EPS files. You may save a plot using the save function. ","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"Note that saving an interactive plot in a non-interactive file format, such as .pdf or .svg will result in a warning WARN Can not resolve event source: window, but the plot will be saved as a static image. If you wish to preserve interactive capabilities, you may save it using the .vegalite file extension. If you then open this file in Jupyter lab, the interactive aspects will be preserved.","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"p = Mimi.plot(m, :mycomponent, :myvariable)\nsave(\"MyFilePath.svg\", p)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"More specifically for our tutorial use of FUND, try:","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"p = Mimi.plot(m, :socioeconomic, :income)\nsave(\"MyFilePath.svg\", p)","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"","category":"page"},{"location":"tutorials/tutorial_2/#","page":"2 Run an Existing Model","title":"2 Run an Existing Model","text":"You're done!  Now feel free to move on to the next tutorial, which will go into depth on how to modify an existing model such as FUND.","category":"page"},{"location":"tutorials/tutorial_7/#Tutorial-7:-Couple-Two-Existing-Models-1","page":"Tutorial 7: Couple Two Existing Models","title":"Tutorial 7: Couple Two Existing Models","text":"","category":"section"},{"location":"tutorials/tutorial_7/#","page":"Tutorial 7: Couple Two Existing Models","title":"Tutorial 7: Couple Two Existing Models","text":"We have written up a repository and accompanying notebook here to demonstrate the steps to couple together two existing models, both configured as packages, specifically in this case replacing (most of) the FUND model's climate module with the FAIR model.","category":"page"},{"location":"howto_advanced/howto_adv_main/#Advanced-How-to-Guides-Introduction-1","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Introduction","text":"","category":"section"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"The following how-to guides provide steps to work through more specified and advanced real-world problems that Mimi can solve. They are less detailed than the tutorials, and are thus targeted at a user with some level of experience with Mimi (likely obtained through moving through some or all of the tutorials). ","category":"page"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"If you find a bug in these guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"howto_advanced/howto_adv_main/#Available-Advanced-How-to-Guides-1","page":"Advanced How-to Guides Intro","title":"Available Advanced How-to Guides","text":"","category":"section"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"Advanced How-to Guide: Build and Init Functions describes the innerworkings of the build and init functions which may be useful in special cases.","category":"page"},{"location":"howto_advanced/howto_adv_main/#","page":"Advanced How-to Guides Intro","title":"Advanced How-to Guides Intro","text":"Advanced How-to Guide: Using Datum References describes how to use references to datum, or more specifically components, for scenarios where such use improves code brevity and understandability.","category":"page"},{"location":"explanations/exp_pkgs/#Explanations:-Models-as-Packages-1","page":"Models as Packages","title":"Explanations: Models as Packages","text":"","category":"section"},{"location":"explanations/exp_pkgs/#Models-as-Packages-1","page":"Models as Packages","title":"Models as Packages","text":"","category":"section"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Pkg (more detail here)is Julia's builtin package manager, and handles operations such as installing, updating and removing packages. It is often convenient to set Mimi models up as julia packages using the steps described here. \"A package is a project with a name, uuid and version entry in the Project.toml file, and a src/PackageName.jl file that defines the module PackageName. This file is executed when the package is loaded.\"","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Models can be registered or unregistered, as described in the next section, but it is not necessary to register a package in order to use the Pkg interface.","category":"page"},{"location":"explanations/exp_pkgs/#Example-1","page":"Models as Packages","title":"Example","text":"","category":"section"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"The MimiDICE2016 model is an unregistered package. As its README instructs, it can be accessed by:","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Running the following command at the julia package REPL:","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"pkg> add https://github.com/AlexandrePavlov/MimiDICE2016.jl","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Now you can use MimiDICE2016 and its exported API:","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"using MimiDICE2016\nm = MimiDICE2016.get_model()\nrun(m)","category":"page"},{"location":"explanations/exp_pkgs/#Registries-and-The-Mimi-Registry-1","page":"Models as Packages","title":"Registries and The Mimi Registry","text":"","category":"section"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Update (5/3/2020): Please note that going forward we are moving away from this model and encouraging registration in the General Registry to keep things simple and seamless for users instead of requiring extra maintenance and communication by our team. This will not be a breaking change, so current models registered with the Mimi registry will work as expected.","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Packages can be registered in a Registry, and \"registries contain information about packages, such as available releases and dependencies, and where they can be downloaded. The General registry is the default one, and is installed automatically\".","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"The Mimi registry is a custom registry maintained by the Mimi development team that co-locates several Mimi models in one central registry in the same way julia co-locates packages in the General registry, where Mimi and other packages you commonly may use are located. While the development team maintains this registry and has some basic requirements such as continuous integration testing (CI) and proper package structure as dictated by julia, they do not claim responsibility or knowledge of the content or quality of the models themselves. ","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"If you are interested in adding a model to the Mimi Registry, please be in touch with the Mimi development team by opening an Issue on the Registry and/or a question on the Mimi forum if you do not receive a timely response. We will aim to create a standard guide for this process soon.","category":"page"},{"location":"explanations/exp_pkgs/#Example-2","page":"Models as Packages","title":"Example","text":"","category":"section"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"The [MimiDICE2010] model is a registered package in the Mimi Registry, and can be accessed by:","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Running the following command at the julia package REPL (only required once):","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Followed by adding the package:","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"pkg> add MimiDICE2010","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"Now you can use MimiDICE2010 and its exported API:","category":"page"},{"location":"explanations/exp_pkgs/#","page":"Models as Packages","title":"Models as Packages","text":"using MimiDICE2010\nm = MimiDICE2010.get_model()\nrun(m)","category":"page"},{"location":"faq/#Frequently-asked-questions-1","page":"FAQ","title":"Frequently asked questions","text":"","category":"section"},{"location":"faq/#What's-up-with-the-name?-1","page":"FAQ","title":"What's up with the name?","text":"","category":"section"},{"location":"faq/#","page":"FAQ","title":"FAQ","text":"The name is probably an acronym for \"Modular Integrated Modeling Interface\", but we are not sure. What is certain is that it came up during a dinner that Bob, David and Sol had in 2015. David thinks that Bob invented the name, Bob doesn't remember and Sol thinks the waiter might have come up with it (although we can almost certainly rule that option out). It certainly is better than the previous name \"IAMF\". We now use \"Mimi\" purely as a name of the package, not as an acronym.","category":"page"},{"location":"ref/ref_composites/#Reference-Guide:-Composite-Components-1","page":"Reference Guide: Composite Components","title":"Reference Guide: Composite Components","text":"","category":"section"},{"location":"ref/ref_composites/#","page":"Reference Guide: Composite Components","title":"Reference Guide: Composite Components","text":"Prior versions of Mimi supported only \"flat\" models, i.e., with one level of components. The current version supports multiple layers of components, with some components being \"final\" or leaf components, and others being \"composite\" components which themselves contain other leaf or composite components. This approach allows for a cleaner organization of complex models, and allows the construction of building blocks that can be re-used in multiple models.","category":"page"},{"location":"ref/ref_composites/#","page":"Reference Guide: Composite Components","title":"Reference Guide: Composite Components","text":"To the degree possible, composite components are designed to operate the same as leaf components, though there are necessarily differences:","category":"page"},{"location":"ref/ref_composites/#","page":"Reference Guide: Composite Components","title":"Reference Guide: Composite Components","text":"Leaf components are defined using the macro @defcomp, while composites are defined using @defcomposite. Each macro supports syntax and semantics specific to the type of component.\nLeaf components support user-defined run_timestep() functions, whereas composites have a built-in run_timestep() function that iterates over its subcomponents and calls their run_timestep() function. The init() function is handled analogously.","category":"page"},{"location":"ref/ref_composites/#","page":"Reference Guide: Composite Components","title":"Reference Guide: Composite Components","text":"... [TODO]","category":"page"},{"location":"ref/ref_structures_classes_types/#Reference-Guide:-Structures-Classes.jl-and-Core-Types-1","page":"Structures: Classes.jl and Types","title":"Reference Guide: Structures - Classes.jl and Core Types","text":"","category":"section"},{"location":"ref/ref_structures_classes_types/#Classes.jl-1","page":"Structures: Classes.jl and Types","title":"Classes.jl","text":"","category":"section"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"NOTE: We plan to soon phase out use of Classes.jl for simplicity","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"Most of the core data structures are defined using the Classes.jl package, which was developed for Mimi, but separated out as a generally useful julia package. The main features of Classes are:","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"Classes can subclass other classes, thereby inheriting the same list of fields as a starting point, which can then be extended with further fields.\nA type hierarchy is defined automatically that allows classes and subclasses to be referenced with a single type. In short, if you define a class Foo, an abstract type called AbstractFoo is defined, along with the concrete class Foo. If you subclass Foo (say with the class Bar), then AbstractBar will be a subtype of AbstractFoo, allowing methods to be defined that operate on both the superclass and subclass. See the Classes.jl documentation for further details.","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"For example, in Mimi, ModelDef is a subclass of CompositeComponentDef, which in turn is a subclass of ComponentDef. Thus, methods can be written with arguments typed x::ComponentDef to operate on leaf components only, or x::AbstractCompositeComponentDef to operate on composites and ModelDef, or as x::AbstractComponentDef to operate on all three concrete types.","category":"page"},{"location":"ref/ref_structures_classes_types/#User-facing-Classes-1","page":"Structures: Classes.jl and Types","title":"User-facing Classes","text":"","category":"section"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"Model: The Model class contains the ModelDef, and after the build() function is called, a ModelInstance that can be run. The API for Model delegates many calls to either its top-level ModeDef or ModelInstance, while providing additional functionality including running a Monte Carlo simulation.\nComponentReference","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"[TODO]","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"VariableReference","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"[TODO]","category":"page"},{"location":"ref/ref_structures_classes_types/#Core-Types-1","page":"Structures: Classes.jl and Types","title":"Core Types","text":"","category":"section"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"Several core types are defined in types/core.jl, including the two primary abstract types, MimiStruct and MimiClass. ","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"All structs and classes in Mimi are derived from these abstract types, which allows us to identify Mimi-defined items when writing show() methods. Some of the important structs and classes include:","category":"page"},{"location":"ref/ref_structures_classes_types/#","page":"Structures: Classes.jl and Types","title":"Structures: Classes.jl and Types","text":"ComponentId\nTo identify components, @defcomp creates a variable with the name of  the component whose value is an instance of this type. The definition is:\njulia  struct ComponentId <: MimiStruct      module_obj::Union{Nothing, Module}      comp_name::Symbol  end\nComponentPath\nA ComponentPath identifies the path from one or more composites to any component, using an NTuple of symbols. Since component names are unique at the composite level, the sequence of names through a component hierarchy uniquely identifies a component in that hierarchy.\njulia  struct ComponentPath <: MimiStruct      names::NTuple{N, Symbol} where N  end","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#Advanced-How-to-Guide:-Build-and-Init-Functions-1","page":"Build and Init Functions","title":"Advanced How-to Guide: Build and Init Functions","text":"","category":"section"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"In some cases, it may be useful for a user to better understand the inner-workings of the internal build function, as well as the ModelInstance and ModelDef types. In addition, components with one-time computations irrespective of timesteps may lend themselves to the use of the optional init function, as described below.","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#The-Internal-'build'-Function-and-Model-Instances-1","page":"Build and Init Functions","title":"The Internal 'build' Function and Model Instances","text":"","category":"section"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"The structural definition of a Model is held in the mutable ModelDef, and then when you call the run function on your model, first the internal build function is called, which produces a ModelInstance, and then the ModelInstance is run. A model instance is an instantiated version of the model you have designed where all of the component constructors have been called and all of the data arrays have been allocated. If you wish to create and run multiple versions of your model, you can use the intermediate build function and store the separate ModelInstances. This may be useful if you want to change some parameter values, while keeping the model's structure mostly the same. For example:","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"instance1 = Mimi.build(m)\nrun(instance1)\n\nupdate_param!(m, ParameterName, newvalue)\ninstance2 = Mimi.build(m)\nrun(instance2)\n\nresult1 = instance1[:Comp, :Var]\nresult2 = instance2[:Comp, :Var]","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"Note that you can retrieve values from a ModelInstance in the same way you index into a model.","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#The-init-function-1","page":"Build and Init Functions","title":"The init function","text":"","category":"section"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"The init function can optionally be called within @defcomp and before run_timestep.  Similarly to run_timestep, this function is called with parameters init(p, v, d), where the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined.   ","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"If defined for a specific component, this function will run before the timestep loop, and should only be used for parameters or variables without a time index e.g. to compute the values of scalar variables that only depend on scalar parameters. Note that when using init, it may be necessary to add special handling in the run_timestep function for the first timestep, in particular for difference equations.  A skeleton @defcomp script using both run_timestep and init would appear as follows:","category":"page"},{"location":"howto_advanced/howto_adv_buildinit/#","page":"Build and Init Functions","title":"Build and Init Functions","text":"@defcomp component1 begin\n\n    # First define the state this component will hold\n    savingsrate = Parameter()\n\n    # Second, define the (optional) init function for the component\n    function init(p, v, d)\n    end\n\n    # Third, define the run_timestep function for the component\n    function run_timestep(p, v, d, t)\n    end\n\nend","category":"page"},{"location":"tutorials/tutorial_4/#Tutorial-4:-Create-a-Model-1","page":"4 Create a Model","title":"Tutorial 4: Create a Model","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"This tutorial walks through the steps to create a new model, first a one-region model and then a more complex multi-region model. ","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"While we will walk through the code step by step below, the full code for implementation is also available in the examples/tutorial folder in the Mimi github repository.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_4/#Constructing-A-One-Region-Model-1","page":"4 Create a Model","title":"Constructing A One-Region Model","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"In this example, we construct a stylized model of the global economy and its changing greenhouse gas emission levels through time. The overall strategy involves creating components for the economy and emissions separately, and then defining a model where the two components are coupled together.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"There are two main steps to creating a component, both within the  @defcomp macro which defines a component:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"List the parameters and variables.\nUse the run_timestep function run_timestep(p, v, d, t) to set the equations of that component.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Starting with the economy component, each variable and parameter is listed. If either variables or parameters have a time-dimension, that must be set with (index=[time]).","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Next, the run_timestep function must be defined along with the various equations of the grosseconomy component. In this step, the variables and parameters are linked to this component and must be identified as either a variable or a parameter in each equation. For this example, v will refer to variables while p refers to parameters.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"It is important to note that t below is an AbstractTimestep, and the specific API for using this argument are described in detail in the how to guide How-to Guide 4: Work with Timesteps.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi # start by importing the Mimi package to your space\n\n@defcomp grosseconomy begin\n\tYGROSS\t= Variable(index=[time])\t# Gross output\n\tK\t= Variable(index=[time])\t# Capital\n\tl\t= Parameter(index=[time])\t# Labor\n\ttfp\t= Parameter(index=[time])\t# Total factor productivity\n\ts\t= Parameter(index=[time])\t# Savings rate\n\tdepk\t= Parameter()\t\t\t# Depreciation rate on capital - Note that it has no time index\n\tk0\t= Parameter()\t\t\t# Initial level of capital\n\tshare\t= Parameter()\t\t\t# Capital share\n\n\tfunction run_timestep(p, v, d, t)\n\t\t# Define an equation for K\n\t\tif is_first(t)\n\t\t\t# Note the use of v. and p. to distinguish between variables and \n\t\t\t# parameters\n\t\t\tv.K[t] \t= p.k0\t\n\t\telse\n\t\t\tv.K[t] \t= (1 - p.depk)^5 * v.K[t-1] + v.YGROSS[t-1] * p.s[t-1] * 5\n\t\tend\n\n\t\t# Define an equation for YGROSS\n\t\tv.YGROSS[t] = p.tfp[t] * v.K[t]^p.share * p.l[t]^(1-p.share)\n\tend\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Next, the component for greenhouse gas emissions must be created.  Although the steps are the same as for the grosseconomy component, there is one minor difference. While YGROSS was a variable in the grosseconomy component, it now enters the emissions component as a parameter. This will be true for any variable that becomes a parameter for another component in the model.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"@defcomp emissions begin\n\tE\t= Variable(index=[time])\t# Total greenhouse gas emissions\n\tsigma\t= Parameter(index=[time])\t# Emissions output ratio\n\tYGROSS\t= Parameter(index=[time])\t# Gross output - Note that YGROSS is now a parameter\n\n\tfunction run_timestep(p, v, d, t)\n\n\t# Define an equation for E\n\tv.E[t] = p.YGROSS[t] * p.sigma[t]\t# Note the p. in front of YGROSS\n\tend\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"We can now use Mimi to construct a model that binds the grosseconomy and emissions components together in order to solve for the emissions level of the global economy over time. In this example, we will run the model for twenty periods with a timestep of five years between each period.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Once the model is defined, set_dimension! is used to set the length and interval of the time step.\nWe then use add_comp! to incorporate each component that we previously created into the model.  It is important to note that the order in which the components are listed here matters.  The model will run through each equation of the first component before moving onto the second component. One can also use the optional first and last keyword arguments to indicate a subset of the model's time dimension when the component should start and end.\nNext, update_param! is used to assign values each component parameter with an external connection to an unshared model parameter. If population was a parameter for two different components, it must be assigned to each one using update_param! two different times. The syntax is update_param!(model_name, :component_name, :parameter_name, value).  Alternatively if these parameters are always meant to use the same value, one could use add_shared_param! to create a shared model parameter and add it to the model, and then use connect_param! to connect both. This syntax would use add_shared_param!(model_name, :model_param_name, value) followed by connect_param!(model_name, :component_name, :parameter_name, :model_param_name) twice, once for each component.\nIf any variables of one component are parameters for another, connect_param! is used to couple the two components together. In this example, YGROSS is a variable in the grosseconomy component and a parameter in the emissions component. The syntax is connect_param!(model_name, :component_name_parameter, :parameter_name, :component_name_variable, :variable_name), where :component_name_variable refers to the component where your parameter was initially calculated as a variable.\nFinally, the model can be run using the command run(model_name).\nTo access model results, use model_name[:component, :variable_name].\nTo observe model results in a graphical form , explore as either explore(model_name) to open the UI window, or use Mimi.plot(model_name, :component_name, :variable_name) or Mimi.plot(model_name, :component_name, :parameter_name) to plot a specific parameter or variable.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"\nusing Mimi\n\nfunction construct_model()\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\n\t# Order matters here. If the emissions component were defined first, the model would not run.\n\tadd_comp!(m, grosseconomy)  \n\tadd_comp!(m, emissions)\n\n\t# Update parameters for the grosseconomy component\n\tupdate_param!(m, :grosseconomy, :l, [(1. + 0.015)^t *6404 for t in 1:20])\n\tupdate_param!(m, :grosseconomy, :tfp, [(1 + 0.065)^t * 3.57 for t in 1:20])\n\tupdate_param!(m, :grosseconomy, :s, ones(20).* 0.22)\n\tupdate_param!(m, :grosseconomy, :depk, 0.1)\n\tupdate_param!(m, :grosseconomy, :k0, 130.)\n\tupdate_param!(m, :grosseconomy, :share, 0.3)\n\n\t# Update parameters for the emissions component\n\tupdate_param!(m, :emissions, :sigma, [(1. - 0.05)^t *0.58 for t in 1:20])\n\t\n\t# connect parameters for the emissions component\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)  \n\n\treturn m\n\nend #end function","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Note that as an alternative to using many of the update_param! calls above, one may use the default keyword argument in @defcomp when first defining a Variable or Parameter, as shown in examples/tutorial/01-one-region-model/one-region-model-defaults.jl.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Now we can run the model and examine the results:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"# Run model\nm = construct_model()\nrun(m)\n\n# Check model results\ngetdataframe(m, :emissions, :E) # or m[:emissions, :E_Global] to return just the Array","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Finally we can visualize the results via plotting and explorer:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"# Plot model results\nMimi.plot(m, :emissions, :E);\n\n# Observe all model result graphs in UI\nexplore(m)","category":"page"},{"location":"tutorials/tutorial_4/#Constructing-A-Multi-Region-Model-1","page":"4 Create a Model","title":"Constructing A Multi-Region Model","text":"","category":"section"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"We can now modify our two-component model of the globe to include multiple regional economies.  Global greenhouse gas emissions will now be the sum of regional emissions. The modeling approach is the same, with a few minor adjustments:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"When using @defcomp, a regions index must be specified. In addition, for variables that have a regional index it is necessary to include (index=[regions]). This can be combined with the time index as well, (index=[time, regions]).\nIn the run_timestep function, unlike the time dimension, regions must be specified and looped through in any equations that contain a regional variable or parameter.\nset_dimension! must be used to specify your regions in the same way that it is used to specify your timestep.\nWhen using update_param! for values with a time and regional dimension, an array is used.  Each row corresponds to a time step, while each column corresponds to a separate region. For regional values with no timestep, a vector can be used. It is often easier to create an array of parameter values before model construction. This way, the parameter name can be entered into update_param! rather than an entire equation.\nWhen constructing regionalized models with multiple components, it is often easier to save each component as a separate file and to then write a function that constructs the model.  When this is done, using Mimi must be speficied for each component. This approach will be used here.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"To create a three-regional model, we will again start by constructing the grosseconomy and emissions components, making adjustments for the regional index as needed.  Each component should be saved as a separate file.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"As this model is also more complex and spread across several files, we will also take this as a chance to introduce the custom of using Modules to package Mimi models, as shown below.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi\n\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\n\n    function run_timestep(p, v, d, t)\n    # Note that the regional dimension is defined in d and parameters and variables are indexed by 'r'\n\n        # Define an equation for K\n        for r in d.regions\n            if is_first(t)\n                v.K[t,r] = p.k0[r]\n            else\n                v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n            end\n        end\n\n        # Define an equation for YGROSS\n        for r in d.regions\n            v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n        end\n    end\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this component as gross_economy.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi\t#Make sure to call Mimi again\n\n@defcomp emissions begin\n    regions     = Index()                           # The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   # Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            # Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  # Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  # Gross output - Note that YGROSS is now a parameter\n\n    # function init(p, v, d)\n    # end\n    \n    function run_timestep(p, v, d, t)\n        # Define an equation for E\n        for r in d.regions\n            v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n        end\n\n        # Define an equation for E_Global\n        for r in d.regions\n            v.E_Global[t] = sum(v.E[t,:])\n        end\n    end\n\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this component as emissions.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Let's create a file with all of our parameters that we can call into our model.  This will help keep things organized as the number of components and regions increases. Each column refers to parameter values for a region, reflecting differences in initial parameter values and growth rates between the three regions.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"l = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this file as region_parameters.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"The final step is to create a module:","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"module MyModel\n\nusing Mimi\n\ninclude(\"region_parameters.jl\")\ninclude(\"gross_economy.jl\")\ninclude(\"emissions.jl\")\n\nexport construct_MyModel","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"function construct_MyModel()\n\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\tset_dimension!(m, :regions, [:Region1, :Region2, :Region3])\t # Note that the regions of your model must be specified here\n\n\tadd_comp!(m, grosseconomy)\n\tadd_comp!(m, emissions)\n\n\tupdate_param!(m, :grosseconomy, :l, l)\n\tupdate_param!(m, :grosseconomy, :tfp, tfp)\n\tupdate_param!(m, :grosseconomy, :s, s)\n\tupdate_param!(m, :grosseconomy, :depk,depk)\n\tupdate_param!(m, :grosseconomy, :k0, k0)\n\tupdate_param!(m, :grosseconomy, :share, 0.3)\n\n\tupdate_param!(m, :emissions, :sigma, sigma)\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    return m\nend","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"end #module","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Save this file as MyModel.jl","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"We can now run the model and evaluate the results.","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"using Mimi\n\ninclude(\"MyModel.jl\")\nusing .MyModel","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"m = construct_MyModel()\nrun(m)\n\n# Check results\ngetdataframe(m, :emissions, :E_Global) # or m[:emissions, :E_Global] to return just the Array","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"# Observe model result graphs\nexplore(m)","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"","category":"page"},{"location":"tutorials/tutorial_4/#","page":"4 Create a Model","title":"4 Create a Model","text":"Next, feel free to move on to the next tutorial, which will go into depth on how to run a sensitivity analysis on a own model.","category":"page"},{"location":"tutorials/tutorial_3/#Tutorial-3:-Modify-an-Existing-Model-1","page":"3 Modify an Existing Model","title":"Tutorial 3: Modify an Existing Model","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"This tutorial walks through the steps to modify an existing model.  There are several existing models publically available on Github, and for the purposes of this tutorial we will use the MimiDICE2010 model.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher\nconnection of your julia installation with the central Mimi registry of Mimi models","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_3/#Introduction-1","page":"3 Modify an Existing Model","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"There are various ways to modify an existing model, and this tutorial aims to introduce the Mimi API relevant to this broad category of tasks.  It is important to note that regardless of the goals and complexities of your modifications, the API aims to allow for modification without alteration of the original code for the model being modified.  Instead, you will download and run the existing model, and then use API calls to modify it. This means that in practice, you should not need to alter the source code of the model you are modifying. This should make it simple to keep up with any external updates or improvements made to that model. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Possible modifications range in complexity, from simply altering parameter values, to adjusting an existing component, to adding a brand new component.","category":"page"},{"location":"tutorials/tutorial_3/#Parametric-Modifications:-The-API-1","page":"3 Modify an Existing Model","title":"Parametric Modifications: The API","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Several types of changes to models revolve around the parameters themselves, and may include updating the values of parameters and changing parameter connections without altering the elements of the components themselves or changing the general component structure of the model.  The most useful functions of the common API in these cases are likely update_param!/update_params!, add_shared_param!, disconnect_param! and connect_param!.  For detail on these functions see the How-to Guide 5: Work with Parameters and Variables and the API reference guide, Reference Guide: The Mimi API.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"By the Mimi structure, the parameters in a model you start with receive their values either from an exogenously set model parameters (shared or unshared as described in How To Guide 5) through an external parameter connection, or from another component's variable through an internal parameter connection.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The functions update_param! and update_params! allow you to change the value associated with a given model parameter, and thus value connected to the respective component-parameter pair(s) connected to it. If the model parameter is a shared model parameter you can use the following to update it:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_param!(mymodel, :model_parameter_name, newvalues)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If the model parameter is unshared, and thus the value can only be connected to one component/parameter pair, you can use the following to update it:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_param!(mymodel, :comp_name, :param_name, newvalues)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Note here that newvalues must be the same type (or be able to convert to the type) of the old values stored in that parameter, and the same size as the model dimensions indicate. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If you are unsure whether the component-parameter pair you wish to update is connected to a shared or unshared model parameter use the latter, four argument call above and an error message will give you specific instructions on how to proceed. As described in How To Guide 5, parameters default to being unshared.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The functions disconnect_param! and connect_param! can be used to alter or add connections within an existing model. These two can be used in conjunction with each other to update the connections within the model, although this is more likely to be done as part of larger changes involving components themselves, as discussed in the next subsection.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Once again, for specific instructions and details on various cases of updating and changing parameters, and their connections, please view How-to Guide 5: Work with Parameters and Variables.  We do not repeat all information here for brevity and to avoid duplication.","category":"page"},{"location":"tutorials/tutorial_3/#Parametric-Modifications:-DICE-Example-1","page":"3 Modify an Existing Model","title":"Parametric Modifications: DICE Example","text":"","category":"section"},{"location":"tutorials/tutorial_3/#Step-1.-Download-MimiDICE2010-1","page":"3 Modify an Existing Model","title":"Step 1. Download MimiDICE2010","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The first step in this process is downloading the DICE2010 model, which is now made easy with the Mimi registry. Assuming you have already done the one-time run of the following to connect your julia installation with the central Mimi registry of Mimi models,","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"you simply need to add the MimiDICE2010 model in the Pkg REPL with:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"pkg> add MimiDICE2010","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"You have now successfully downloaded MimiDICE2010 to your local machine.","category":"page"},{"location":"tutorials/tutorial_3/#Step-2.-Run-DICE-1","page":"3 Modify an Existing Model","title":"Step 2. Run DICE","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The next step is to run DICE using the provided API for the package:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"using MimiDICE2010\nm = MimiDICE2010.get_model()\nrun(m)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"These steps should be relatively consistent across models, where a repository for ModelX should contain a primary file ModelX.jl which exports, at minimum, a function named something like get_model or construct_model which returns a version of the model, and can allow for model customization within the call.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In this case, the function MimiDICE2010.get_model() has the signature","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"get_model(params=nothing)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Thus there are no required arguments, although the user can input params, a dictionary definining the parameters of the model. If nothing is provided, the model will be built with the default parameters for DICE2010.","category":"page"},{"location":"tutorials/tutorial_3/#Step-3.-Altering-Parameters-1","page":"3 Modify an Existing Model","title":"Step 3. Altering Parameters","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In the case that you wish to alter an parameter retrieving an exogenously set value from a model parameter, you may use the update_param! function.  Per usual, you will start by importing the Mimi package to your space with ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"using Mimi","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"In DICE the parameter fco22x is the forcings of equilibrium CO2 doubling in watts per square meter, and is a shared model parameter (named fco22x) and connected to component parameters with the same name, fco22x, in components climatedynamics and radiativeforcing.  We can change this value from its default value of 3.200 to 3.000 in both components, using the following code:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_param!(m, :fco22x, 3.000)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"A more complex example may be a situation where you want to update several parameters, including some with a :time dimension, in conjunction with altering the time index of the model itself. DICE uses a default time horizon of 2005 to 2595 with 10 year increment timesteps.  If you wish to change this, say, to 1995 to 2505 by 10 year increment timesteps and use parameters that match this time, you could use the following code:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"First you update the time dimension of the model as follows:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"const ts = 10\nconst years = collect(1995:ts:2505)\nnyears = length(years)\nset_dimension!(m, :time, years)","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"At this point all parameters with a :time dimension have been slightly modified under the hood, but the original values are still tied to their original years.  In this case, for example, the model parameter has been shorted by 9 values (end from 2595 –> 2505) and padded at the front with a value of missing (start from 2005 –> 1995). Since some values, especially initializing values, are not time-agnostic, we maintain the relationship between values and time labels.  If you wish to attach new values, you can use update_param! as below.  In this case this is probably necessary, since having a missing in the first spot of a parameter with a :time dimension will likely cause an error when this value is accessed.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Updating the :time dimension can be tricky, depending on your use case, so we recommend reading How-to Guide 6: Update the Time Dimension if you plan to do this often in your work.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"To batch update shared model parameters, create a dictionary params with one entry (k, v) per model parameter you want to update by name k to value v. Each key k must be a symbol or convert to a symbol matching the name of a shared model parameter that already exists in the model definition.  Part of this dictionary may look like:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"params = Dict{Any, Any}()\nparams[:a1]         = 0.00008162\nparams[:a2]         = 0.00204626\n...\nparams[:S]          = repeat([0.23], nyears)\n...","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"To batch update unshared model parameters, follow a similar pattern but use tuples (:compname, :paramname) as your dictionary keys, which might look like:","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"params = Dict{Any, Any}()\nparams[(:comp1, :a1)]         = 0.00008162\nparams[(:comp1, :a2)]         = 0.00204626\n...\nparams[(:comp2, :S)]          = repeat([0.23], nyears)\n...","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Finally, you can combine these two dictionaries and Mimi will recognize and resolve the two different key types under the hood. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Now you simply update the parameters listen in params and re-run the model with","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"update_params!(m, params)\nrun(m)","category":"page"},{"location":"tutorials/tutorial_3/#Component-and-Structural-Modifications:-The-API-1","page":"3 Modify an Existing Model","title":"Component and Structural Modifications: The API","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Most model modifications will include not only parametric updates, but also structural changes and component modification, addition, replacement, and deletion along with the required re-wiring of parameters etc. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"We recommend trying to use the user-facing API to modify existing models by importing the model (and with it its various components) as demonstrated in examples such as MimiFUND-MimiFAIR-Flat.jl from Tutorial 7.  When this API is not satisfactory, you may wish to make changes directly to the model repository, which for many completed models is configured as a julia Package. In this case, the use of environments and package versioning may become one level more complicated, so please do not hesitate to reach out on the forum for up-front help on workflow ... pausing for a moment to get that straight will save you a lot of time.  We will work on getting standard videos and tutorials up as resources as well.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"The most useful functions of the common API, in these cases are likely replace!, add_comp! along with delete! and the requisite functions for parameter setting and connecting.  For detail on the public API functions look at the API reference. ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"If you wish to modify the component structure we recommend you also look into the built-in helper components adder, multiplier,ConnectorCompVector, and ConnectorCompMatrix in the src/components folder, as these can prove quite useful.  ","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"adder.jl – Defines Mimi.adder, which simply adds two parameters, input and add and stores the result in output.\nmultiplier.jl – Defines Mimi.multiplier, which simply multiplies two parameters, input and multiply and stores the result in output.\nconnector.jl – Defines a pair of components, Mimi.ConnectorCompVector and Mimi.ConnectorCompMatrix. These copy the value of parameter input1, if available, to the variable output, otherwise the value of parameter input2 is used. It is an error if neither has a value.","category":"page"},{"location":"tutorials/tutorial_3/#Component-and-Structural-Modifications:-DICE-Example-1","page":"3 Modify an Existing Model","title":"Component and Structural Modifications: DICE Example","text":"","category":"section"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"This example is in progress and will be built out soon.","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"","category":"page"},{"location":"tutorials/tutorial_3/#","page":"3 Modify an Existing Model","title":"3 Modify an Existing Model","text":"Next, feel free to move on to the next tutorial, which will go into depth on how to create your own model.","category":"page"},{"location":"internals/structure/#Mimi-Internal-Structure-1","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"","category":"section"},{"location":"internals/structure/#.-Code-organization-1","page":"Mimi Internal Structure","title":"1. Code organization","text":"","category":"section"},{"location":"internals/structure/#Types-1","page":"Mimi Internal Structure","title":"Types","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"All Mimi types are defined in Mimi/src/core/types.jl.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The types are broadly divided into two categories reflecting \"structural definitions\" versus \"instantiated model info\". Structural definition types include:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ModelDef\nComponentDef\nDatumDef (used for both variable and parameter definitions)","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"Instantiated model info types include:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ModelInstance\nComponentInstance\nComponentInstanceVariables\nComponentInstanceParameters","category":"page"},{"location":"internals/structure/#Model-object-1","page":"Mimi Internal Structure","title":"Model object","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The \"user-facing\" Model no longer directly holds other model information: it now holds a ModelDef and, once the model is built, a ModelInstance, and delegates all function calls to one or the other of these, as appropriate. The \"public\" API to models is provided by functions taking a Model instance, which are defined in the file model.jl.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"With this change, all previous \"direct\" access of data in the Model instance are replaced by a functional API. That is, all occurrences of m.xxx (where m::Model) have been replaced with function calls on m, which are then delegated to the ModelDef or ModelInstance, as appropriate.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"To simplify coding the delegated calls, a new macro, @modelegate allows you to write, e.g., ","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"@modelegate external_param_conns(m::Model) => mi","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"which translates to:","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"external_param_conns(m::Model) = external_param_conns.mi)","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The right-hand side can also be => md to indicate delegation to the ModelDef rather than to the ModelInstance. See model.jl for numerous examples.","category":"page"},{"location":"internals/structure/#Connections-1","page":"Mimi Internal Structure","title":"Connections","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The types InternalParameterConnection and ExternalParameterConnection are now both subtypes of the abstract type Connection.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"[We may merge these two connection types since the only functional differences are that the ExternalParameterConnections type has fewer fields and its instances are stored in a separate list in the model.]","category":"page"},{"location":"internals/structure/#ComponentInstanceData-1","page":"Mimi Internal Structure","title":"ComponentInstanceData","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"ComponentInstanceVariables and ComponentInstanceParameters are parametric types that are subtypes of ComponentInstanceData. The names and types of the variables or parameters are encoded into the type information; the struct proper contains only the parameter or variable values. Use of this parametric type allows us to use @generated to produce type-specific getproperty and setproperty! functions that efficiently access model parameters. [See Dot-overloading, below.]","category":"page"},{"location":"internals/structure/#.-Changes-to-@defcomp-1","page":"Mimi Internal Structure","title":"2. Changes to @defcomp","text":"","category":"section"},{"location":"internals/structure/#Macro-simplification-1","page":"Mimi Internal Structure","title":"Macro simplification","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"The @defcomp macro has been substantially simplified by relying on MacroTools.jl package and by avoiding the construction of expressions using Abstract Syntax Tree form. The macro now operates by producing a fairly simple sequence of function calls.","category":"page"},{"location":"internals/structure/#Dot-overloading-1","page":"Mimi Internal Structure","title":"Dot-overloading","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In a change from the prior iteration of Mimi, the run_timestep function must now be defined within the @defcomp macro. It takes four arguments: parameters, variables, dimensions, and time.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"    function run_timestep(p, v, d, t)\n       ...\n    end","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"With the run_timestep function inside the @defcomp macro, we are able to modify the code to translate references like p.gdp and assignments like v.foo = 3 to use new @generated functions getproperty and setproperty!, which compile down to direct array access operations on the values field of parameter and variable instances.","category":"page"},{"location":"internals/structure/#Component-naming-1","page":"Mimi Internal Structure","title":"Component naming","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In the previous version of Mimi, components were named by a pair of symbols indicating the module the component was defined in, and the name of the component. Each component was also reified in a newly generated custom type.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"In the new version, all component definitions are represented by one type, ComponentDef. The @defcomp macro creates a global variable with the name provided to @defcomp which holds a new type of object, ComponentId, which holds the symbol names of the module and component. The name of the model given in the @defcomp macro invocation becomes a variable holding the ComponentId. Thus, instead of referring to a component as, say, (:Mimi, :grosseconomy), you refer to it by its associated global constant, e.g., Mimi.grosseconomy. Note that models can be defined in their own module to avoid namespace collisions.","category":"page"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"(Image: Object structure)","category":"page"},{"location":"internals/structure/#.-Pre-compilation-and-built-in-components-1","page":"Mimi Internal Structure","title":"3. Pre-compilation and built-in components","text":"","category":"section"},{"location":"internals/structure/#","page":"Mimi Internal Structure","title":"Mimi Internal Structure","text":"To get __precompile__() to work required moving the creation of \"helper\" components to an __init__() method in Mimi.jl, which is run automatically after Mimi loads. It defines the three \"built-in\" components, from adder.jl, multiplier.jl, and connector.jl in the components subdirectory.","category":"page"},{"location":"ref/ref_main/#Reference-Guides-Introduction-1","page":"Reference Guides Intro","title":"Reference Guides Introduction","text":"","category":"section"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"The following reference guides are technical descriptions of the Mimi machinery, organized around the actual code behind Mimi and intended to be information-oriented for those interested in the internals or needing to more deeply understand those aspects in order to carry out their projects. Given the complexity of this code base, these references are not comprehensive, but intended to target some important and relevant aspects of Mimi.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"If you find a bug in these reference guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"ref/ref_main/#Available-Reference-Guides-1","page":"Reference Guides Intro","title":"Available Reference Guides","text":"","category":"section"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: The Mimi API provides a guide to the public API for Mimi, including macros, types, and functions along with their signatures and descriptions.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Structures - Classes.jl and Core Types describes the use of Classes.jl in Mimi as well as some of the core Types used to implement Mimi 1.0.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Structures - Definitions describes the core definition data structures used to implement Mimi 1.0.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Structures - Instances describes the core instance data structures used to implement Mimi 1.0.","category":"page"},{"location":"ref/ref_main/#","page":"Reference Guides Intro","title":"Reference Guides Intro","text":"Reference Guide: Composite Components describes the introduction of composite components in Mimi 1.0.","category":"page"},{"location":"tutorials/tutorial_5/#Tutorial-5:-Monte-Carlo-Simulations-and-Sensitivity-Analysis-Support-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Tutorial 5: Monte Carlo Simulations and Sensitivity Analysis Support","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"This tutorial walks through the Monte Carlo simulation and sensitivity analysis (SA) functionality of Mimi, including core routines and examples.  We will start with looking at using the Monte Carlo and SA routines with the multi-region Mimi model built in the second half of Tutorial 3, which is also available in the Mimi repository at examples/tutorial/02-multi-region-model. Then we will show some more advanced features using a real Integrated Assessment model, MimiDICE2010.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"For a more complete understanding of the Monte Carlo and SA Support, we recommend following up by reading How-to Guide 3: Conduct Monte Carlo Simulations and Sensitivity Analysis.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Working through the following tutorial will require:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Julia v1.4.0 or higher\nMimi v0.10.0 or higher","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"If you have not yet prepared these, go back to the first tutorial to set up your system.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"MimiDICE2010 is required for the second example in this tutorial. If you are not yet comfortable with downloading and running a registered Mimi model, refer to Tutorial 2 for instructions.","category":"page"},{"location":"tutorials/tutorial_5/#The-API-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"The API","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"The best current documentation on the SA API is the how to guide How-to Guide 3: Conduct Sensitivity Analysis. This file can be used in conjunction with the examples below for details since the documentation covers more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in this tutorial.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Below we will refer separately to two types, SimulationDef and SimulationInstance.  They are referred to as sim_def and sim_inst respectively as function arguments, and sd and si respectively as local variables.","category":"page"},{"location":"tutorials/tutorial_5/#Multi-Region-Model-Example-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Multi-Region Model Example","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"This section will walk through a simple example of how to define a simulation, run the simulation for a given model, and access the outputs.","category":"page"},{"location":"tutorials/tutorial_5/#Step-1.-Setup-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Step 1. Setup","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"You should have Mimi installed by now, and if you do not have the Distributions package, take a moment to add that package by entering ] to enter the Pkg REPL mode and then typing add Distributions.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"As a reminder, the following code is the multi-region model that was constructed in the second half of tutorial 3. You can either load the MyModel module from tutorial 3, or run the following code which defines the same construct_Mymodel function that we will use.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"using Mimi \n\n# Define the grosseconomy component\n@defcomp grosseconomy begin\n    regions = Index()                           #Note that a regional index is defined here\n\n    YGROSS  = Variable(index=[time, regions])   #Gross output\n    K       = Variable(index=[time, regions])   #Capital\n    l       = Parameter(index=[time, regions])  #Labor\n    tfp     = Parameter(index=[time, regions])  #Total factor productivity\n    s       = Parameter(index=[time, regions])  #Savings rate\n    depk    = Parameter(index=[regions])        #Depreciation rate on capital - Note that it only has a region index\n    k0      = Parameter(index=[regions])        #Initial level of capital\n    share   = Parameter()                       #Capital share\n\n    function run_timestep(p, v, d, t)\n    # Note that the regional dimension is defined in d and parameters and variables are indexed by 'r'\n\n        # Define an equation for K\n        for r in d.regions\n            if is_first(t)\n                v.K[t,r] = p.k0[r]\n            else\n                v.K[t,r] = (1 - p.depk[r])^5 * v.K[t-1,r] + v.YGROSS[t-1,r] * p.s[t-1,r] * 5\n            end\n        end\n\n        # Define an equation for YGROSS\n        for r in d.regions\n            v.YGROSS[t,r] = p.tfp[t,r] * v.K[t,r]^p.share * p.l[t,r]^(1-p.share)\n        end\n    end\nend\n\n# define the emissions component\n@defcomp emissions begin\n    regions     = Index()                           # The regions index must be specified for each component\n\n    E           = Variable(index=[time, regions])   # Total greenhouse gas emissions\n    E_Global    = Variable(index=[time])            # Global emissions (sum of regional emissions)\n    sigma       = Parameter(index=[time, regions])  # Emissions output ratio\n    YGROSS      = Parameter(index=[time, regions])  # Gross output - Note that YGROSS is now a parameter\n\n    # function init(p, v, d)\n    # end\n    \n    function run_timestep(p, v, d, t)\n        # Define an equation for E\n        for r in d.regions\n            v.E[t,r] = p.YGROSS[t,r] * p.sigma[t,r]\n        end\n\n        # Define an equation for E_Global\n        for r in d.regions\n            v.E_Global[t] = sum(v.E[t,:])\n        end\n    end\n\nend\n\n# Define values for input parameters to be used when constructing the model\n\nl = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    l[t,1] = (1. + 0.015)^t *2000\n    l[t,2] = (1. + 0.02)^t * 1250\n    l[t,3] = (1. + 0.03)^t * 1700\nend\n\ntfp = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    tfp[t,1] = (1 + 0.06)^t * 3.2\n    tfp[t,2] = (1 + 0.03)^t * 1.8\n    tfp[t,3] = (1 + 0.05)^t * 2.5\nend\n\ns = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    s[t,1] = 0.21\n    s[t,2] = 0.15\n    s[t,3] = 0.28\nend\n\ndepk = [0.11, 0.135 ,0.15]\nk0   = [50.5, 22., 33.5]\n\nsigma = Array{Float64}(undef, 20, 3)\nfor t in 1:20\n    sigma[t,1] = (1. - 0.05)^t * 0.58\n    sigma[t,2] = (1. - 0.04)^t * 0.5\n    sigma[t,3] = (1. - 0.045)^t * 0.6\nend\n\n# Define a function for building the model\n\nfunction construct_MyModel()\n\n\tm = Model()\n\n\tset_dimension!(m, :time, collect(2015:5:2110))\n\tset_dimension!(m, :regions, [:Region1, :Region2, :Region3])\t # Note that the regions of your model must be specified here\n\n\tadd_comp!(m, grosseconomy)\n\tadd_comp!(m, emissions)\n\n\tupdate_param!(m, :grosseconomy, :l, l)\n\tupdate_param!(m, :grosseconomy, :tfp, tfp)\n\tupdate_param!(m, :grosseconomy, :s, s)\n\tupdate_param!(m, :grosseconomy, :depk,depk)\n\tupdate_param!(m, :grosseconomy, :k0, k0)\n\tupdate_param!(m, :grosseconomy, :share, 0.3)\n\n\tupdate_param!(m, :emissions, :sigma, sigma)\n\tconnect_param!(m, :emissions, :YGROSS, :grosseconomy, :YGROSS)\n\n    return m\nend","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Then, we obtain a copy of the model:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"m = construct_MyModel()","category":"page"},{"location":"tutorials/tutorial_5/#Step-2.-Define-the-Simulation-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Step 2. Define the Simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"The @defsim macro is the first step in the process, and returns a SimulationDef. The following syntax allows users to define random variables (RVs) as distributions,  and associate model parameters with the defined random variables.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"There are two ways of assigning random variables to model parameters in the @defsim macro. Notice that both of the following syntaxes are used in the following example. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"The first is the following:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"rv(rv1) = Normal(0, 0.8)    # create a random variable called \"rv1\" with the specified distribution\nparam1 = rv1                # then assign this random variable \"rv1\" to the shared model parameter \"param1\" in the model\ncomp1.param2 = rv1          # then assign this random variable \"rv1\" to the unshared model parameter \"param2\" in component `comp1`","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"The second is a shortcut, in which you can directly assign the distribution on the right-hand side to the name of the model parameter on the left hand side. With this syntax, a single random variable is created under the hood and then assigned to our shared model parameter param1 and unshared model parameter param2.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"param1 = Normal(0, 0.8)\ncomp1.param2 = Normal(1,0)","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Note here that if we have a shared model parameter we can assign based on its name, but if we have an unshared model parameter specific to one component/parameter pair we need to specify both.  If the component is not specified Mimi will throw a warning and try to resolve under the hood with assumptions, proceeding if possible and erroring if not.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"It is important to note that for each trial, a random variable on the right hand side of an assignment, be it using an explicitly defined random variable with rv(rv1) syntax or using shortcut syntax as above, will take on the value of a single draw from the given distribution.  This means that even if the random variable is applied to more than one parameter on the left hand side (such as assigning to a slice), each of these parameters will be assigned the same value, not different draws from the distribution","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"The @defsim macro also selects the sampling method. Simple random sampling (also called Monte Carlo sampling) is the default. Other options include Latin Hypercube sampling and Sobol sampling. Below we show just one example of a @defsim call, but the How-to guide referenced at the beginning of this tutorial gives a more comprehensive overview of the options.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"using Mimi\nusing Distributions \n\nsd = @defsim begin\n\n    # Define random variables. The rv() is only required when defining correlations \n    # or sharing an RV across parameters. Otherwise, you can use the shortcut syntax\n    # to assign a distribution to a parameter name.\n    rv(name1) = Normal(1, 0.2)\n    rv(name2) = Uniform(0.75, 1.25)\n    rv(name3) = LogNormal(20, 4)\n\n    # Define the sampling strategy, and if you are using LHS, you can define \n    # correlations like this:\n    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])\n\n    # assign RVs to model Parameters\n    grosseconomy.share = Uniform(0.2, 0.8)\n\n    # you can use the *= operator to replace the values in the parameter with the \n    # product of the original value and the value of the RV for the current \n    # trial (note that in both lines below, all indexed values will be mulitplied by the\n    # same draw from the given random parameter (name2 or Uniform(0.8, 1.2))\n    emissions.sigma[:, Region1] *= name2\n    emissions.sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)\n\n    # For parameters that have a region dimension, you can assign an array of distributions, \n    # keyed by region label, which must match the region labels in the model\n    grosseconomy.depk = [Region1 => Uniform(0.7, .9),\n            Region2 => Uniform(0.8, 1.),\n            Region3 => Truncated(Normal(), 0, 1)]\n\n    # Indicate which variables to save for each model run.\n    # The syntax is: component_name.variable_name\n    save(grosseconomy.K, grosseconomy.YGROSS, \n         emissions.E, emissions.E_Global)\nend","category":"page"},{"location":"tutorials/tutorial_5/#Step-3.-Run-Simulation-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Step 3. Run Simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Next, use the run function to run the simulation for the specified simulation definition, model (or list of models), and number of trials. View the internals documentation here for critical and useful details on the full signature of the run function.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"In its simplest use, the run function generates and iterates over a sample of trial data from the distributions of the random variables defined in the SimulationDef, perturbing the subset of Mimi's model parameters that have been assigned random variables, and then runs the given Mimi model(s) for each set of trial data. The function returns a SimulationInstance, which holds a copy of the original SimulationDef in addition to trials information (trials, current_trial, and current_data), the model list models, and results information in results. Optionally, trial values and/or model results are saved to CSV files. Note that if there is concern about in-memory storage space for the results, use the results_in_memory flag set to false to incrementally clear the results from memory. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"# Run 100 trials, and optionally save results to the indicated directories\nsi = run(sd, m, 100; trials_output_filename = \"/tmp/trialdata.csv\", results_output_dir=\"/tmp/tutorial4\")\n\n# Explore the results saved in-memory by using getdataframe with the returned SimulationInstance.\n# Values are saved from each trial for each variable or parameter specified by the call to \"save()\" at the end of the @defsim block.\nK_results = getdataframe(si, :grosseconomy, :K)\nE_results = getdataframe(si, :emissions, :E)","category":"page"},{"location":"tutorials/tutorial_5/#Step-4.-Explore-and-Plot-Results-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Step 4. Explore and Plot Results","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"As described in the internals documentation here, Mimi provides both explore and Mimi.plot to explore the results of both a run Model and a run SimulationInstance. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"To view your results in an interactive application viewer, simply call:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"explore(si)","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"If desired, you may also include a title for your application window. If more than one model was run in your Simulation, indicate which model you would like to explore with the model keyword argument, which defaults to 1. Finally, if your model leverages different scenarios, you must indicate the scenario_name.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"explore(si; title = \"MyWindow\", model_index = 1) # we do not indicate scen_name here since we have no scenarios","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"To view the results for one of the saved variables from the save command in @defsim, use the (unexported to avoid namespace collisions) Mimi.plot function.  This function has the same keyword arguments and requirements as explore (except for title), and three required arguments: the SimulationInstance, the component name (as a Symbol), and the variable name (as a Symbol).","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Mimi.plot(si, :grosseconomy, :K)","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"To save your figure, use the save function to save typical file formats such as PNG, SVG, PDF and EPS files. Note that while explore(sim_inst) returns interactive plots for several graphs, Mimi.plot(si, :foo, :bar) will return only static plots. ","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"p = Mimi.plot(si, :grosseconomy, :K)\nsave(\"MyFigure.png\", p)","category":"page"},{"location":"tutorials/tutorial_5/#Advanced-Features-Social-Cost-of-Carbon-(SCC)-Example-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Advanced Features - Social Cost of Carbon (SCC) Example","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"This example will discuss the more advanced SA capabilities of post-trial functions and payload objects.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Case: We want to do an SCC calculation with MimiDICE2010, which consists of running both a base and modified model (the latter being a model including an additional emissions pulse, see the create_marginal_model function or create your own two models). We then take the difference between the consumption level in these two models and obtain the discounted net present value to get the SCC.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"The beginning steps for this case are identical to those above. We first define the typical variables for a simulation, including the number of trials N and the simulation definition sd.  In this case we only define one random variable, t2xco2, but note there could be any number of random variables defined here.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"using Mimi\nusing MimiDICE2010\nusing Distributions\n\n# define the number of trials\nN = 100\n\n# define your simulation (defaults to Monte Carlo sampling)\nsd = @defsim begin\n    t2xco2 = Truncated(Gamma(6.47815626,0.547629469), 1.0, Inf) # a dummy distribution\nend","category":"page"},{"location":"tutorials/tutorial_5/#Payload-object-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Payload object","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Simulation definitions can hold a user-defined payload object which is not used or modified by Mimi. In this example, we will use the payload to hold an array of pre-computed discount factors that we will use in the SCC calculation, as well as a storage array for saving the SCC values.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"# Choose what year to calculate the SCC for\nscc_year = 2015\nyear_idx = findfirst(isequal(scc_year), MimiDICE2010.model_years)\n\n# Pre-compute the discount factors for each discount rate\ndiscount_rates = [0.03, 0.05, 0.07]\nnyears = length(MimiDICE2010.model_years)\ndiscount_factors = [[zeros(year_idx - 1)... [(1/(1 + r))^((t-year_idx)*10) for t in year_idx:nyears]...] for r in discount_rates] \n\n# Create an array to store the computed SCC in each trial for each discount rate\nscc_results = zeros(N, length(discount_rates))  \n\n# Set the payload object in the simulation definition\nmy_payload_object = (discount_factors, scc_results) # In this case, the payload object is a tuple which holds both both arrays\nMimi.set_payload!(sd, my_payload_object)","category":"page"},{"location":"tutorials/tutorial_5/#Post-trial-function-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Post-trial function","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"In the simple multi-region simulation example, the only values that were saved during each trial of the simulation were values of variables calculated internally by the model. Sometimes, a user may need to perform other calculations before or after each trial is run. For example, the SCC is calculated using two models, so this calculation needs to happen in a post-trial function, as shown below.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Here we define a post_trial_function called my_scc_calculation which will calculate the SCC for each trial of the simulation. Notice that this function retrieves and uses the payload object that was previously stored in the SimulationDef.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"function my_scc_calculation(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Nothing)\n    mm = sim_inst.models[1] \n    discount_factors, scc_results = Mimi.payload(sim_inst)  # Unpack the payload object\n\n    marginal_damages = mm[:neteconomy, :C] * -1 * 10^12 * 12/44 # convert from trillion $/ton C to $/ton CO2; multiply by -1 to get positive value for damages\n    for (i, df) in enumerate(discount_factors)\n        scc_results[trialnum, i] = sum(df .* marginal_damages .* 10)\n    end\nend","category":"page"},{"location":"tutorials/tutorial_5/#Run-the-simulation-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Run the simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"Now that we have our post-trial function, we can proceed to obtain our two models and run the simulation. Note that we are using a Mimi MarginalModel mm from MimiDICE2010, which is a Mimi object that holds both the base model and the model with the additional pulse of emissions.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"# Build the marginal model\nmm = MimiDICE2010.get_marginal_model(year = scc_year)   # The additional emissions pulse will be added in the specified year\n\n# Run\nsi = run(sd, mm, N; trials_output_filename = \"ecs_sample.csv\", post_trial_func = my_scc_calculation)\n\n# View the scc_results by retrieving them from the payload object\nscc_results = Mimi.payload(si)[2]   # Recall that the SCC array was the second of two arrays we stored in the payload tuple\n","category":"page"},{"location":"tutorials/tutorial_5/#Other-Helpful-Functions-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Other Helpful Functions","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"A small set of unexported functions are available to modify an existing SimulationDef.  Please refer to How-to Guide 3: Conduct Monte Carlo Simulations and Sensitivity Analysis for an in depth description of their use cases.  The functions include the following:","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"delete_RV!\nadd_RV!\nreplace_RV!\ndelete_transform!\nadd_transform!\ndelete_save!\nadd_save!\nget_simdef_rvnames\nset_payload!\npayload","category":"page"},{"location":"tutorials/tutorial_5/#Full-list-of-keyword-options-for-running-a-simulation-1","page":"5 Monte Carlo + Sensitivity Analysis","title":"Full list of keyword options for running a simulation","text":"","category":"section"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"View How-to Guide 3: Conduct Monte Carlo Simulations and Sensitivity Analysis for critical and useful details on the full signature of this function, as well as more details and optionality for more advanced use cases.","category":"page"},{"location":"tutorials/tutorial_5/#","page":"5 Monte Carlo + Sensitivity Analysis","title":"5 Monte Carlo + Sensitivity Analysis","text":"function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;\n                 ntimesteps::Int=typemax(Int), \n                 trials_output_filename::Union{Nothing, AbstractString}=nothing, \n                 results_output_dir::Union{Nothing, AbstractString}=nothing, \n                 pre_trial_func::Union{Nothing, Function}=nothing, \n                 post_trial_func::Union{Nothing, Function}=nothing,\n                 scenario_func::Union{Nothing, Function}=nothing,\n                 scenario_placement::ScenarioLoopPlacement=OUTER,\n                 scenario_args=nothing,\n                 results_in_memory::Bool=true) where T <: AbstractSimulationData","category":"page"},{"location":"howto/howto_9/#How-to-Guide-9:-Port-to-New-Parameter-API-1","page":"9 Port to New Param API","title":"How-to Guide 9: Port to New Parameter API","text":"","category":"section"},{"location":"howto/howto_9/#...-phasing-out-set_param!-for-all-update_param!-1","page":"9 Port to New Param API","title":"... phasing out set_param! for all update_param!","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"In the most recent feature release, Mimi presents a new, encouraged API for working with parameters that will hopefully be (1) simpler (2) clearer and (3) avoid unexpected behavior created by too much \"magic\" under the hood, per user requests.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The following will first summarize the new, encouraged API and then take the next section to walk through the suggested ways to move from the older API, which includes set_param!, to the new API, which phases out set_param!.  This release should not be breaking meaning that moving from the older to newer API may be done on your own time, although we would encourage taking the time to do so.  Per usual, use the forum to ask any questions you may have, we will monitor closely to help work through corner cases etc.   ","category":"page"},{"location":"howto/howto_9/#The-New-API-1","page":"9 Port to New Param API","title":"The New API","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Here we briefly summarize the new, encouraged parameter API.  We encourage users to follow-up by reading How-to Guide 5: Work with Parameters and Variables's \"Parameters\" section for a detailed description of this new API, since the below is only a summary for brevity and to avoid duplication.  We also note a related change to the @defsim Monte Carlo Simulation macro.  ","category":"page"},{"location":"howto/howto_9/#Parameters-1","page":"9 Port to New Param API","title":"Parameters","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Component parameters in Mimi obtain values either (1) from a variable calculated by another component and passed through an internal connection or (2) from an externally set value stored in a model parameter.  For the latter case, model parameters can be unshared, such that they can only connect to one component/parameter pair and must be accessed by specifying both the component and component's parameter name, or shared, such that they can connect to multiple component/parameter pairs and have a unique name they can be referenced with. ","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"In the next few subsections we will present the API for setting, connecting, and updating parameters as presented by different potential use cases. The API consists of only a few primary functions:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_param!\nadd_shared_param!\ndisconnect_param!\nconnect_param!","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"along with the useful functions for batch setting:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_params!\nupdate_leftover_params!","category":"page"},{"location":"howto/howto_9/#Monte-Carlo-Simulations-1","page":"9 Port to New Param API","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"We have introduced new syntax to the monte carlo simulation definition macro @defsim to handle both shared and unshared parameters.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Previously, one would always assign a random variable to a model parameter with syntax like:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"rv(myrv) = Normal(0,1)\nmyparameter = myrv\n# or the shortcut:\nmyparameter = Normal(0,1)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Now, this syntax will only work if myparameter is a shared model parameter and thus accessible with that name.  If the parameter is an unshared model parameter, use dot syntax like","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"rv(myrv) = Normal(0,1)\nmycomponent.myparameter = myrv\n# or the shortcut:\nmycomponent.myparameter = Normal(0,1)","category":"page"},{"location":"howto/howto_9/#Porting-to-the-New-API-1","page":"9 Port to New Param API","title":"Porting to the New API","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"On a high level, calls to set_param! always related to shared model parameters, so it very likely that almost all of your current parameters are shared model parameters.  The exception is parameters that are set by default = ... arguments in their @defcomp and then never reset, these will automatically be unshared model parameters.  ","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The changes you will want to make consist of (1) deciding which parameters you actually want to be connected to shared model parameters vs those you want to be connected to unshared model parameters (probably the majority) and (2) updating your code accordingly. You also may need to make related updates to @defsim Monte Carlo simulation definitions.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"This section is not exhaustive, especially since set_param! has quite a few different methods for different permutations of arguments, so please don't hesitate to get in touch with questions about your specific use cases!","category":"page"},{"location":"howto/howto_9/#set_param!-and-update_param!-1","page":"9 Port to New Param API","title":"set_param! and update_param!","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The Mimi Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"A call to set_param! is equivalent to the the now suggested combination of calls to add_shared_param! and connect_param!.  For example:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"set_param!(m, comp_name, param_name, model_param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"is equivalent to ","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"add_shared_param!(m, model_param_name, value)\nconnect_param!(m, comp_name, param_name, model_param_name)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"and similarly a call to ","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"set_param!(m, comp_name, param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"is equivalent to","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"add_shared_param!(m, model_param_name, value) # shared parameter gets the same name as the component parameter\nconnect_param!(m, comp_name, param_name, param_name) # once per component with a parameter named `param_name`","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"A call to update_param! retains the same functionality, such that","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_param!(m, model_param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"will update a shared model parameter with name model_param_name to value, thus updating all component/parameter pairs externally connected to this shared model parameter.  In addition, we now present a new update_param!:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_param!(m, comp_name, param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"which will update the unshared model parameter externally connected to comp_name's param_name to value. If comp_name's param_name is connected to a shared model parameter, this call will error and present specific suggestions for either updating the shared model parameter or explicitly disconnecting your desired parameter before proceeding.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Finally, add_shared_param! has two optional keyword arguments, dims and data_type, which mirror specifications you gave in your @defcomp parameter definition and might be needed. Again we include error messages to alert you of this.  Specifically:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"dims::Vector{Symbol}: If your shared model parameter will be connected to parameters with dimensions, like one defined in @defcomp with p = Parameter(index = [time]), you'll need to specify dimensions with add_shared_param!(m, :model_param_name, value; dims = [time]).  \ndata_type::DataType: If your shared model parameter will be connected to parameters with dimensions, like one defined in @defcomp with p = Parameter{Int64}(), you may need to specify dimensions with add_shared_param!(m, :model_param_name, value; data_type = Int64) although we will try to interpret this under the hood for you.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Appropriate error messages will instruct you to designate these if you forget to do so, and also recognize related problems with connections to parameters.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The User Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Taking a look at your code, if you see a call to set_param!, first decide if this is a case where you want to create a shared model parameter that can be connected to several component/parameter pairs. In many cases you will see a call to set_param! with four arguments:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"set_param!(m, comp_name, param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"and the desired behavior is that this component/parameter pair be connected to an unshared model parameter.  To do this, change set_param! to update_param! with the same arguments:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_param!(m, comp_name, param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"This will simply update the value of the unshared model parameter specific to comp_name and param_name, which will be the sentinal value nothing if it has not been touched since add_comp!. Recall that now you do not have a model parameter accessible using just param_name, your unshared model parameter has a hidden and under-the-hood unique name to prevent collisions, but you will only be able to access the model parameter value with a combination of comp_name and param_name. Updating this parameter in the future thus uses the same syntax:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_param!(m, comp_name, param_name, new_value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Now, suppose you actually do want to create a shared model parameter.  In this case, you may see a call to set_param! like:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"set_param!(m, param_name, value)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"and you may want to keep this as the creation of and connection to a shared model parameter.  In this case, you will use a combination of calls:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"add_shared_param!(m, param_name, value)\nconnect_param!(m, comp_name_1, param_name, param_name)\nconnect_param!(m, comp_name_2, param_name, param_name)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"where the call to connect_param! must be made once for each component/parameter pair you want to connect to the shared model parameter, which previously was done under the hood by searching for all component's with a parameter with the name param_name. Note that in this new syntax, it's actually preferable not to use the same param_name for your shared model parameter.  ","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"To keep your scripts understandable, we would actually recommend using a different parameter name, like follows.  You can also connect parameters to this shared model parameter that do not share its name. In essense Mimi will not make assumptions that component's with the same parameter name should get the same value, you must be explicit:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"add_shared_param!(m, model_param_name, value)\nconnect_param!(m, comp_name_1, param_name_1, model_param_name)\nconnect_param!(m, comp_name_2, param_name_2, model_param_name)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Now you have a shared model parameter accessible with model_param_name and updating this parameter in the future can thus use the three argument update_param! syntax:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_param!(m, model_param_name, new_value)","category":"page"},{"location":"howto/howto_9/#update_params!-1","page":"9 Port to New Param API","title":"update_params!","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The Mimi Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Previously, one could batch update a set of parameters using a Dict and the function update_params!, which you passed a model m and a dictionary parameters with entries k => v where the key k was a Symbol matching the name of a shared model parameter and v the desired value.  This will still work for shared model parameters, but we have added a new type of entry k => v where k is a Tuple of (component_name, parameter_name). ","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The signature for this function is:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"update_params!(m::Model, parameters::Dict)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"For each (k, v) pair in the provided parameters dictionary, update_params! is called to update the model parameter identified by the key to value v. For updating unshared parameters, each key k must be a Tuple matching the name of a component in m and the name of an parameter in that component. For updating shared parameters, each key k must be a Symbol (or convert to a Symbol) matching the name of a shared model parameter that already exists in the model.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"For example, given a model m with a shared model parameter model_param_name connected to several component parameters, and two unshared model parameters p1 and p2 in a component A:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"# update shared model parameters and unshared model parameters separately\nshared_dict = Dict(:model_param_name => 1)\nunshared_dict = Dict((:A, :p5) => 2, (:A, :p6) => 3)\nupdate_params!(m, shared_dict)\nupdate_params!(m, unshared_dict)\n\n# update both at the same time\ndict = Dict(:model_param_name => 1, (:A, :p5) => 2, (:A, :p6) => 3)\nupdate_params!(m, dict)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The User Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Current calls to update_params! will still work as long as the keys are shared model parameters, if they no longer exist in your model as shared model parameters you'll need to make the key a Tuple like above. ","category":"page"},{"location":"howto/howto_9/#update_leftover_params!-1","page":"9 Port to New Param API","title":"update_leftover_params!","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The Mimi Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Previously, one could batch set all unset parameters in a model using a Dict and the function set_leftover_params!, which you passed a model m and a dictionary parameters with entries k => v where the key k was a Symbol or String matching the name of a shared model parameter and v the desired value.  This will still work, and will always create a new shared model parameter for each key.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"We have added a new function update_leftover_params! that does the same high-level operation, but updates the values of the already created unshared model parameters for each provided key entry k => v, where k is a Tuple of Strings or Symbols (component_name, parameter_name). This avoids creation of undesired shared model parameters, and the connection of more than one component-parameter pair to the same shared model parameter without explicit direction from the user.","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The User Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"We recommend moving to use of update_leftover_params! by changing your dictionary keys to be (component_name, parameter_name).  If previous calls to set_leftover_params! created shared model parameters with multiple connected component-parameter pairs and you want to maintain this behavior, you should do this explicitly with the aforementioned combination of add_shared_param! and a series of calls to connect_param!.","category":"page"},{"location":"howto/howto_9/#Monte-Carlo-Simulations-with-@defsim-1","page":"9 Port to New Param API","title":"Monte Carlo Simulations with @defsim","text":"","category":"section"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The Mimi Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Previously, one would always assign a random variable to a model parameter with syntax like:","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"myparameter = Normal(0,1)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"or","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"rv(myrv) = Normal(0,1)\nmyparameter = myrv","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"Now, this syntax will only work if myparameter is a shared model parameter and thus accessible with that name.  If the parameter is an unshared model parameter, use dot syntax like","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"mycomponent.myparameter = Normal(0,1)","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"or","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"rv(myrv) = Normal(0,1)\nmycomponent.myparameter = myrv","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The User Change","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"In an attempt to make this transition smooth, if you use the former syntax with an unshared model parameter, such as one that is set with a default, we will throw a warning and try under the hood to resolve which unshared model parameter you are trying to refer to.  If we can figure it out without unsafe assumptions, we will warn about the assumption we are asking and proceed.  If we can't do so safely, we will error. If you encounter this error case, just get in touch and we will help you update your code since this release is not supposed to break code!","category":"page"},{"location":"howto/howto_9/#","page":"9 Port to New Param API","title":"9 Port to New Param API","text":"The easiest way to make this update is to run your existing code and look for warning and error messages which should give explicit descriptions of how to move forward to silence the warnings or resolve the errors.","category":"page"},{"location":"howto/howto_6/#How-to-Guide-6:-Update-the-Time-Dimension-1","page":"6 Update Time Dimension","title":"How-to Guide 6: Update the Time Dimension","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"A runnable model necessarily has a time dimension, originally set with the following call, but in some cases it may be desireable to alter this dimension by calling the following on a model which already has a time dimension set.","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"set_dimension!(m, :time, time_keys)","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"","category":"page"},{"location":"howto/howto_6/#For-example,-one-may-wish-to-replace-the-FUND-model's-climate-module-with-a-different-one,-such-as-FAIR:-1","page":"6 Update Time Dimension","title":"For example, one may wish to replace the FUND model's climate module with a different one, such as FAIR:","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"For the purposes of this guide we focus on the first step of such modification. Since FUND runs yearly from 1950 to 3000 and FAIR yearly from 1765 to 2500, our modified model will need to run yearly from 1765 to 1950.","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"We start with FUND","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"using Mimi\nusing MimiFUND\nm = MimiFUND.get_model()","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"where MimiFUND.get_model includes the call set_dimension!(m, time, 1950:3000).","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"","category":"page"},{"location":"howto/howto_6/#Now-we-need-to-change-the-time-dimension-to-be-1765-to-2500:-1","page":"6 Update Time Dimension","title":"Now we need to change the time dimension to be 1765 to 2500:","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"Before we do so, note some important rules and precautions. These are in place to avoid unexpected behavior, complications, or incorrect results caused by our under-the-hood assumptions, but if a use case arises where these are prohibitive please get in touch on the forum and we can help you out.","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"The new time dimension cannot start later than the original time dimension.  \nThe new time dimension cannot end before the start of the original time dimension ie. it cannot completely exclude all times in the original time dimension.\nThe new time dimension must use the same timestep lengths as the original dimension.","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"","category":"page"},{"location":"howto/howto_6/#We-now-go-ahead-and-change-the-time-dimension-to-be-1765-to-2500:-1","page":"6 Update Time Dimension","title":"We now go ahead and change the time dimension to be 1765 to 2500:","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"set_dimension!(m, :time, 1765:2500)","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"At this point the model m can be run, and will run from 1765 to 2500 (Try running it and looking at explore(m) for parameters and variables with a time dimension!). In fact, we could start adding FAIR components to the model, which would automatically take on the entire model time dimension, ie.","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"add_comp!(m, FAIR_component) # will run from 1765 to 1950","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"However, the FUND components will only run in the subset of years 1950 to 2500, using the same parameter values each year was previously associated with, and containing placeholder missing values in the parameter value spots from 1765 to 1949. More specifically:","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"The model's time dimension values are updated, and it will run for each year in the new 1765:1950 dimension.   julia> Mimi.time_labels(m)   736-element Vector{Int64}: [1765, 1766, 1767,  …  2498, 2499, 2500]\nThe components time dimension values are updated, but (1) the components maintain the first year as set implicitly by the original time dimension (1950) so the run period start year does not change and (2) they maintain their last year as set implicitly by the original time dimension, unless that year is now later than the model's last year, in which case it is trimmed back to the time dimensions last year (2500).  Thus, the components will run for the same run period, or a shorter one if the new time dimension ends before the component used to (in this case 1950:2500).   julia> component = m.md.namespace[:emissions] # get component def(ignore messy internals syntax)   julia> component.dim_dict[:time]   [1765, 1766, 1767,  …  2498, 2499, 2500]   julia> component.first   1950   julia> component.last   2500\nAll model parameters are trimmed and padded as needed so the model can still run, and the values are still linked to their original years.  More specifically, if the new time dimension ends earlier than the original one than the parameter value vector/matrix is trimmed at the end.  If the new time dimension starts earlier than the original, or ends later, the parameter values are padded with missings at the front and/or back respectively.   julia> parameter_values = Mimi.model_params(m)[:currtaxn2o].values.data # get param values for use in next run (ignore messy internals syntax)   julia> size(parameter_values)   (736, 16)   julia> parameter_values[1:(1950-1765),:] # all missing   julia> parameter_values[(1950-1764),:] # hold set values","category":"page"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"","category":"page"},{"location":"howto/howto_6/#The-following-options-are-now-available-for-further-modifications-if-this-end-state-is-not-desireable:-1","page":"6 Update Time Dimension","title":"The following options are now available for further modifications if this end state is not desireable:","text":"","category":"section"},{"location":"howto/howto_6/#","page":"6 Update Time Dimension","title":"6 Update Time Dimension","text":"If you want to update a component's run period, you may use the function Mimi.set_first_last!(m, :ComponentName, first = new_first, last = new_last) to specify when you want the component to run.\nYou can update shared model parameters to have values in place of the assumed missings using the update_param! function ","category":"page"},{"location":"howto/howto_8/#How-to-Guide-8:-Port-from-()-Mimi-v0.5.0-to-Mimi-v1.0.0-1","page":"8 Port to v1.0.0","title":"How-to Guide 8: Port from (>=) Mimi v0.5.0 to Mimi v1.0.0","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The release of Mimi v1.0.0 is a breaking release, necessitating the adaptation of existing models' syntax and structure in order for those models to run on this new version.  We have worked hard to keep these changes clear and as minimal as possible. ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"This guide provides an overview of the steps required to get most models using the v0.9.5 API working with v1.0.0.  It is not a comprehensive review of all changes and new functionalities, but a guide to the minimum steps required to port old models between versions.  For complete information on the new version and its additional functionalities, see the full documentation.","category":"page"},{"location":"howto/howto_8/#Workflow-Advice-1","page":"8 Port to v1.0.0","title":"Workflow Advice","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"To port your model, we recommend you update to Mimi v0.10.0, which is identical to Mimi v1.0.0 except that it includes deprecation warnings for most breaking changes, instead of errors. This means that models written using Mimi v0.9.5 will, in most cases, run successfully under Mimi v0.10.0 and things that will cause errors in v1.0.0 will throw deprecation warnings. These can guide your changes, and thus a good workflow would be:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Update your environment to use Mimi v0.10.0 with   julia  pkg> add Mimi#v0.10.0\nRead through this guide to get a sense for what has changed\nRun your code and incrementally update it, using the deprecation warnings as guides for what to change and the instructions in this guide as explanations, until no warnings are thrown and you have changed anything relevant to your code that is explained in this gude.\nUpdate to Mimi v1.0.0 with the following code, which will update Mimi to it's latest version, v1.0.0  julia  pkg> free Mimi\nRun your model! Things should run smoothly now. If not double check the guide, and feel free to reach out on the forum with any questions. Also, if you are curious about the reasons behind a change, just ask!","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"This guide is organized into a few main sections, each descripting an independent set of changes that can be undertaken in any order desired. ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Syntax Within the @defcomp Macro\nThe set_param! Function\nThe replace_comp! Function\nDifferent-length Components\nMarginal Models\nSimulation Syntax\nComposite Components (optional)","category":"page"},{"location":"howto/howto_8/#Syntax-Within-the-@defcomp-Macro-1","page":"8 Port to v1.0.0","title":"Syntax Within the @defcomp Macro","text":"","category":"section"},{"location":"howto/howto_8/#Type-parameterization-for-Parameters-1","page":"8 Port to v1.0.0","title":"Type-parameterization for Parameters","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"To be consistent with julia syntax, Mimi now uses bracketing syntax to type-parameterize Parameters inside the @defcomp macro instead of double-colon syntax. h","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Where you previously indicated that the parameter a should be an Int with ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"@defcomp my_comp begin\n    a::Int = Parameter()\n    function run_timestep(p, v, d, t)\n    end\nend","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"you should now use","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"@defcomp my_comp begin\n    a = Parameter{Int}()\n    function run_timestep(p, v, d, t)\n    end\nend","category":"page"},{"location":"howto/howto_8/#Integer-Indexing-1","page":"8 Port to v1.0.0","title":"Integer Indexing","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"For safety, Mimi no longer allows indexing into Parameters or Varaibles with the run_timestep function of the @defcomp macro with integers. Instead, this functionality is supported with two new types: TimestepIndex and TimestepValue. Complete details on indexing options can be found in How-to Guide 4: Work with Timesteps, Parameters, and Variables, but below we will describe the minimum steps to get your models working.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Where you previously used integers to index into a Parameter or Variable, you should now use the TimestepIndex type.  For example, the code","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[10]\nend","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"should now read","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[TimestepIndex(10)]\nend","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Also, if you previously used logic to determine which integer index pertained to a specific year, and then used that integer for indexing, you should now use the TimestepValue type. For example, if you previously knew that the index 2 referred to the year 2012, and added that value to a parameter with","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[t] + p.my_other_param[2]\nend","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"you should now use","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"function run_timestep(p, v, d, t)\n    v.my_var[t] = p.my_param[t] + p.my_other_param[TimestepValue(2012)]\nend","category":"page"},{"location":"howto/howto_8/#is_timestep-and-is_time-1","page":"8 Port to v1.0.0","title":"is_timestep and is_time","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"For simplicity and consistency with the change above, Mimi no longer supports the is_timestep or is_time functions and has replaced this functionality with comparison operators combined with the afformentioned TimestepValue and TimestepIndex types.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Any instance of the is_timestep function should be replaced with simple comparison with a TimestepIndex object ie. replace the logic if is_timestep(t, 10) ... with if t == TimestepIndex(10) ....","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Any instance of the is_time function should be repalced with simple comparison with a TimestepValue object ie. replace the logic if is_time(t, 2010) ... with if t == TimestepValue(2010) ....","category":"page"},{"location":"howto/howto_8/#The-set_param!-Function-1","page":"8 Port to v1.0.0","title":"The set_param! Function","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The set_param! method for setting a parameter value in a component now has the following signature:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"set_param!(m::Model, comp_name::Symbol, param_name::Symbol, ext_param_name::Symbol, val::Any)","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"This function creates an external parameter called ext_param_name with value val in the model m's list of external parameters, and connects the parameter param_name in component comp_name to this newly created external parameter. If there is already a parameter called ext_param_name in the model's list of external parameters, it errors.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"There are two available shortcuts:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"# Shortcut 1\nset_param!(m::Model, param_name::Symbol, val::Any)","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"This method creates an external parameter in the model called param_name, sets its value to val, looks at all the components in the model m, finds all the unbound parameters named param_name, and creates connections from all the unbound parameters that are named param_name to the newly created external parameter. If there is already a parameter called param_name in the external parameter list, it errors.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"# Shortcut 2\nset_param!(m::Model, comp_name::Symbol, param_name::Symbol, val::Any)","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"This method creates a new external parameter called param_name in the model m (if that already exists, it errors), sets its value to val, and then connects the parameter param_name in component comp_name to this newly created external parameter.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Any old code that uses the set_param! method with only 4 arguments (shortcut #2 shown above) will still work for setting parameters if they are found in only one component ... but if you have multiple components that have parameters with the same name, using the old 4-argument version of set_param! multiple times will cause an error. Instead, you need to determine what behavior you want across multiple components with parameters of the same name:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"If you want parameters with the same name that are found in multiple components to have the same value, use the 3-argument method:  set_param!(m, :param_name, val). You only have to call this once and it will set the same value for all components with an unconnected parameter called param_name.\nIf you want different components that have parameters with the same name to have different values, then you need to call the 5-argument version of set_param! individually for each parameter value, such as:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"set_param!(m, :comp1, :foo, :foo1, 25)  # creates an external parameter called :foo1 with value 25, and connects just comp1/foo to that value\nset_param!(m, :comp2, :foo, :foo2, 30)  # creates an external parameter called :foo2 with value 30, and connects just comp2/foo to that value","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Also, you can no longer call set_param! to change the value of a parameter that has already been set in the model. If the parameter has already been set, you must use the following to change it:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"update_param!(m, ext_param_name, new_val)","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"This updates the value of the external parameter called ext_param_name in the model m's list of external parameters. Any component that have parameters connected to this external parameter will now be connected to this new value.","category":"page"},{"location":"howto/howto_8/#The-replace_comp!-Function-1","page":"8 Port to v1.0.0","title":"The replace_comp! Function","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"For simplicity, the replace_comp! function has been replaced with a method augmenting the julia Base replace! function.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Where you previously used","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"replace_comp!(m, new, old)","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"to replace the old component with new, they should now use","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"replace!(m, old => new)","category":"page"},{"location":"howto/howto_8/#Different-length-Components-1","page":"8 Port to v1.0.0","title":"Different-length Components","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Update: This Functionality has been reenabled, please feel free to use it again, your old code should now be valid again. ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Through Mimi v0.9.4, the optional keyword arguments first and last could be used to specify times for components that do not run for the full length of the model, like this: add_comp!(mymodel, ComponentC; first=2010, last=2100). This functionality is still disabled, as it was starting in v0.9.5, and all components must run for the full length of the model's time dimension. This functionality may be re-implemented in a later version of Mimi.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Refactor your model so that all components are the same length. You may use the run_timestep function within each component to dictate it's behavior in different timesteps, including doing no calculations for a portion of the full model runtime.","category":"page"},{"location":"howto/howto_8/#Marginal-Models-1","page":"8 Port to v1.0.0","title":"Marginal Models","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"For clarity, the previously named marginal attribute of a Mimi MarginalModel has been renamed to modified.  Hence a MarginalModel is now described as a Mimi Model whose results are obtained by subtracting results of one base Model from those of another marginal Model that has a difference of delta with the signature:","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Any previous access to the marginal attribute of a MarginalModel, mm below, should be changed from ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"model = mm.marginal","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"to","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"model = mm.modified","category":"page"},{"location":"howto/howto_8/#Simulation-Syntax-1","page":"8 Port to v1.0.0","title":"Simulation Syntax","text":"","category":"section"},{"location":"howto/howto_8/#Results-Access-1","page":"8 Port to v1.0.0","title":"Results Access","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"For clarity of return types, Mimi no longer supports use of square brackets (a shortcut for julia Base getindex) to access the results of a Monte Carlo analysis, which are stored in the SimulationInstance.  Instead, access to resulst is supported with the getdataframe function, which will return the results in the same type and format as the square bracket method used to return.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Results previously obtained with ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"results = si[:grosseconomy, :K]","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"should now be obtained with ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"results = getdataframe(si, :grosseconomy, :K)","category":"page"},{"location":"howto/howto_8/#Simulation-Definition-Modification-Functions-1","page":"8 Port to v1.0.0","title":"Simulation Definition Modification Functions","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"For consistency with julia syntax rules, the small set of unexported functions available to modify an existing SimulationDefinition have been renamed, moving from a camel case format to an underscore-based format as follows.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"Replace your functions as follows.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"deleteRV! –> delete_RV!\naddRV! –> add_RV!\nreplaceRV! –> replace_RV!\ndeleteTransform! –> delete_transform!\naddTransform! –> add_transform!\ndeleteSave! –> delete_save!\naddSave! –> add_save!","category":"page"},{"location":"howto/howto_8/#Composite-Components-(optional)-1","page":"8 Port to v1.0.0","title":"Composite Components (optional)","text":"","category":"section"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The Mimi Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The biggest functionality addition of Mimi v1.0.0 is the inclusion of composite components.  Prior versions of Mimi supported only \"flat\" models, i.e., with one level of components. This new version supports mulitple layers of components, with some components being \"final\" or leaf components, and others being \"composite\" components which themselves contain other leaf or composite components. This approach allows for a cleaner organization of complex models, and allows the construction of building blocks that can be re-used in multiple models.","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"The User Change: ","category":"page"},{"location":"howto/howto_8/#","page":"8 Port to v1.0.0","title":"8 Port to v1.0.0","text":"All previous models are considered \"flat\" models, i.e. they have only one level of components, and do not need to be converted into multiple layer models to run. Thus this addition does not mean users need to alter their models, but we encourage you to check out the other documentation on composite components to learn how you can enhance your current models and built better onces in the future!","category":"page"},{"location":"howto/howto_1/#How-to-Guide-1:-Construct-and-Run-a-Model-1","page":"1 Construct + Run a Model","title":"How-to Guide 1: Construct and Run a Model","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"This how-to guide pairs nicely with Tutorial 4: Create a Model and Tutorial 6: Create a Model Including Composite Components, and serves as a higher-level version and refresher for those with some experience with Mimi.  If this is your first time constructing and running a Mimi model, we recommend you start with Tutorial 4 (and Tutorial 6 if you are interested in composite components), which will give you more detailed step-by step instructions.","category":"page"},{"location":"howto/howto_1/#Defining-Components-1","page":"1 Construct + Run a Model","title":"Defining Components","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Any Mimi model is made up of at least one component, so before you construct a model, you need to create your components. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Mimi provides two types of components, leaf components and composite components, which generally match intuitively with the classic computer science tree data structure. Note that many existing models are \"flat models\" with one layer of components, and thus only contain leaf components.","category":"page"},{"location":"howto/howto_1/#Leaf-Components-1","page":"1 Construct + Run a Model","title":"Leaf Components","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"A leaf component can have any number of parameters and variables. Parameters are data values that will be provided to the component as input, and variables are values that the component will calculate in the run_timestep function when the model is run. The index of a parameter or variable determines the number of dimensions that parameter or variable has. They can be scalar values and have no index, such as parameter 'c' in the example below. They can be one-dimensional, such as the variable 'A' and the parameters 'd' and 'f' below. They can be two dimensional such as variable 'B' and parameter 'e' below. Note that any index other than 'time' must be declared at the top of the component, as shown by regions = Index() below.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The user must define a run_timestep function for each component. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"We define a leaf component in the following way:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"using Mimi\n\n@defcomp MyComponentName begin\n  regions = Index()\n\n  A = Variable(index = [time])\n  B = Variable(index = [time, regions])\n\n  c = Parameter()\n  d = Parameter(index = [time])\n  e = Parameter(index = [time, regions])\n  f = Parameter(index = [regions])\n\n  function run_timestep(p, v, d, t)\n    v.A[t] = p.c + p.d[t]\n    for r in d.regions\n      v.B[t, r] = p.f[r] * p.e[t, r]\n    end\n  end\nend","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The run_timestep function is responsible for calculating values for each variable in that component.  Note that the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined. You can access each parameter, variable, or dimension using dot notation as shown above.  The fourth argument is an AbstractTimestep, i.e., either a FixedTimestep or a VariableTimestep, which represents which timestep the model is at.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The API for using the fourth argument, represented as t in this explanation, is described in a following how-to guide How-to Guide 4: Work with Timesteps, Parameters, and Variables. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To access the data in a parameter or to assign a value to a variable, you must use the appropriate index or indices (in this example, either the Timestep or region or both).","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"By default, all parameters and variables defined in the @defcomp will be allocated storage as scalars or Arrays of type Float64. For a description of other data type options, see How-to Guide 5: Work with Parameters and Variables ","category":"page"},{"location":"howto/howto_1/#Composite-Components-1","page":"1 Construct + Run a Model","title":"Composite Components","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Composite components can contain any number of subcomponents, which can be either leaf components or more composite components. To the degree possible, composite components are designed to operate in the same way as leaf components, although there are a few necessary differences:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Leaf components are defined using the macro @defcomp, while Composite components are defined using @defcomposite. Each macro supports syntax and semantics specific to the type of component.\nLeaf components support user-defined run_timestep() functions, whereas composites have a built-in run_timestep() function that iterates over its subcomponents and calls their run_timestep() function.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"A composite component can have any number of parameters and variables, which point to one or more parameters or variables in the composite's subcomponents.  Data all eventually flows through to the leaf components, where calculations are made at runtime and then data is bubbled up into composite components as necessary.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Note that it is not imperative that you explicitly define parameters or variables in a composite component.  It may be desireable for specific use cases, such as ease of access for future connections, future model modification, connecting multiple subcomponent parameters or variables to one higher level component parameter or variable, or parameter conflict resolution (explained below). ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"We define a composite component in the following way:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"First we will need to have defined some leaf components:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"@defcomp Leaf1 begin\n    par_1_1 = Parameter(index=[time])      \n    var_1_1 = Variable(index=[time])       \n    foo = Parameter()\n\n    function run_timestep(p, v, d, t)\n        v.var_1_1[t] = p.par_1_1[t]\n    end\nend\n\n@defcomp Leaf2 begin\n    par_2_1 = Parameter(index=[time])      \n    par_2_2 = Parameter(index=[time])      \n    var_2_1 = Variable(index=[time])      \n    foo = Parameter()\n\n    function run_timestep(p, v, d, t)\n        v.var_2_1[t] = p.par_2_1[t] + p.foo * p.par_2_2[t]\n    end\nend","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Now we construct a composite component MyCompositeComponent which holds the two subcomponents, Leaf1 and Leaf2:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"@defcomposite MyCompositeComponent begin\n    Component(Leaf1)\n    Component(Leaf2)\n\n    foo1 = Parameter(Leaf1.foo)\n    foo2 = Parameter(Leaf2.foo)\n\n    var_2_1 = Variable(Leaf2.var_2_1)\n\n    connect(Leaf2.par_2_1, Leaf1.var_1_1)\n    connect(Leaf2.par_2_2, Leaf1.var_1_1)\nend","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The connect calls are responsible for making internal connections between any two components held by a composite component, similar to connect_param! described in the Model section below. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"As mentioned above, conflict resolution refers to cases where two subcomponents have identically named parameters, and thus the user needs to explicitly demonstrate that they are aware of this and create a new shared model parameter that will point to all subcomponent parameters with that name.  For example, given leaf components A and B: ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"@defcomp Leaf1 begin\n    p1 = Parameter()\n    v1 = Variable(index=[time])\nend\n\n@defcomp Leaf2 begin\n    p1 = Parameter()\nend","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The following will fail because you need to resolve the namespace collision of the p1's:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"@defcomposite MyCompositeComponent begin\n    Component(Leaf1)\n    Component(Leaf2)\nend","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Fix it with a call to Parameter as follows:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"@defcomposite MyCompositeComponent begin\n    Component(Leaf1)\n    Component(Leaf2)\n        \n    p1 = Parameter(Leaf1.p1, Leaf2.p1)\nend","category":"page"},{"location":"howto/howto_1/#Constructing-a-Model-1","page":"1 Construct + Run a Model","title":"Constructing a Model","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Continuing the analogy of a tree data structure, one may consider the Model to be the root, orchestrating the running of all components it contains.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The first step in constructing a model is to set the values for each index of the model. Below is an example for setting the 'time' and 'regions' indexes. The time index expects either a numerical range or an array of numbers.  If a single value is provided, say '100', then that index will be set from 1 to 100. Other indexes can have values of any type.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"using Mimi\n\nm = Model()\nset_dimension!(m, :time, 1850:2200)\nset_dimension!(m, :regions, [\"USA\", \"EU\", \"LATAM\"])","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"A Note on Time Indexes: It is important to note that the values used for the time index are the start times of the timesteps.  If the range or array of time values has a uniform timestep length, the model will run through the last year of the range with a last timestep period length consistent with the other timesteps.  If the time values are provided as an array with non-uniform timestep lengths, the model will run through the last year in the array with a last timestep period length assumed to be one. ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The next step is to add components to the model. This is done by the following syntax:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"add_comp!(m, ComponentA)\nadd_comp!(m, ComponentA, :GDP)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The first argument to add_comp! is the model, the second is the name of the ComponentId defined by @defcomp. If an optional third symbol is provided (as in the second line above), this will be used as the name of the component in this model. This allows you to add multiple versions of the same component to a model, with different names.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The add_comp! function has two more optional keyword arguments, first and last, which can be used to indicate a fixed start and/or end time (year in this case) that the component should run for (within the bounds of the model's time dimension).  For example, the following indicates that ComponentA should only run from 1900 to 2000.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"add_comp!(m, ComponentA; first = 1900, last = 2000)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"The next step is to set the values for all the parameters in the components. Parameters can either have their values assigned from external data, or they can internally connect to the values from variables in other components of the model. When assigned from external data, parameters are externally connected to a model parameter, which can be a shared model parameter with its own name and connected to more than one component-parameter pair, or an unshared model parameter accessible only through the component-parameter pair names and connected solely to that parameter.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To make an external connection to an unshared model parameter, the syntax is as follows:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"update_param!(m, :ComponentName, :ParameterName1, 0.8) # a scalar parameter\nupdate_param!(m, :ComponentName, :ParameterName2, rand(351, 3)) # a two-dimensional parameter","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To make an external connection to a shared model parameter, the syntax is as follows:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"add_shared_param!(m, :ModelParameterName, 1.0) # add a shared model parameter to the model\nconnect_param!(m, :ComponentName, :ParameterName3, :ModelParameterName) # connect component parameter\nconnect_param!(m, :ComponentName, :ParameterName4, :ModelParameterName)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"To make an internal connection, the syntax is as follows.  ","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"connect_param!(m, :TargetComponent, :ParameterName, :SourceComponent, :VariableName)\nconnect_param!(m, :TargetComponent, :ParameterName, :SourceComponent, :VariableName)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"or","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"connect_param!(m, :TargetComponent=>:ParameterName, :SourceComponent=>:VariableName)\nconnect_param!(m, :TargetComponent=>:ParameterName, :SourceComponent=>:VariableName)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"If you wish to delete a component that has already been added, do the following:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"delete!(m, :ComponentName)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"This will delete the component from the model and remove any existing connections it had. Thus if a different component was previously connected to this component, you will need to connect its parameter(s) to something else.","category":"page"},{"location":"howto/howto_1/#Running-a-Model-1","page":"1 Construct + Run a Model","title":"Running a Model","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"After all components have been added to your model and all parameters have been connected to either external values or internally to another component, then the model is ready to be run. Note: at each timestep, the model will run the components in the order you added them. So if one component is going to rely on the value of another component, then the user must add them to the model in the appropriate order.","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"run(m)","category":"page"},{"location":"howto/howto_1/#Long-Example-1","page":"1 Construct + Run a Model","title":"Long Example","text":"","category":"section"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"As a final, lengthier example, below we use the syntax in this tutorial to create and run a toy model with the following structure:","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"      top\n    /     \\\n   A       B\n /  \\     /  \\\n1    2   3    4","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"@defcomp Comp1 begin\n    par_1_1 = Parameter(index=[time])      # external input\n    var_1_1 = Variable(index=[time])       # computed\n    foo = Parameter()\n    function run_timestep(p, v, d, t)\n        v.var_1_1[t] = p.par_1_1[t]\n    end\nend\n\n@defcomp Comp2 begin\n    par_2_1 = Parameter(index=[time])      # connected to Comp1.var_1_1\n    par_2_2 = Parameter(index=[time])      # external input\n    var_2_1 = Variable(index=[time])       # computed\n    foo = Parameter()\n    function run_timestep(p, v, d, t)\n        v.var_2_1[t] = p.par_2_1[t] + p.foo * p.par_2_2[t]\n    end\nend\n\n@defcomp Comp3 begin\n    par_3_1 = Parameter(index=[time])      # connected to Comp2.var_2_1\n    var_3_1 = Variable(index=[time])       # external output\n    foo = Parameter(default=30)\n\n    function run_timestep(p, v, d, t)\n        # @info \"Comp3 run_timestep\"\n        v.var_3_1[t] = p.par_3_1[t] * 2\n    end\nend\n\n@defcomp Comp4 begin\n    par_4_1 = Parameter(index=[time])      # connected to Comp2.var_2_1\n    var_4_1 = Variable(index=[time])        # external output\n    foo = Parameter(default=300)\n\n    function run_timestep(p, v, d, t)\n        # @info \"Comp4 run_timestep\"\n        v.var_4_1[t] = p.par_4_1[t] * 2\n    end\nend\n\n@defcomposite A begin\n    Component(Comp1)\n    Component(Comp2)\n\n    foo1 = Parameter(Comp1.foo)\n    foo2 = Parameter(Comp2.foo)\n\n    var_2_1 = Variable(Comp2.var_2_1)\n\n    connect(Comp2.par_2_1, Comp1.var_1_1)\n    connect(Comp2.par_2_2, Comp1.var_1_1)\nend\n\n@defcomposite B begin\n    Component(Comp3)\n    Component(Comp4)\n\n    foo3 = Parameter(Comp3.foo)\n    foo4 = Parameter(Comp4.foo)\n\n    var_3_1 = Variable(Comp3.var_3_1)\nend\n\n@defcomposite top begin\n    Component(A)\n\n    fooA1 = Parameter(A.foo1)\n    fooA2 = Parameter(A.foo2)\n\n    # TBD: component B isn't getting added to mi\n    Component(B)\n    foo3 = Parameter(B.foo3)\n    foo4 = Parameter(B.foo4)\n\n    var_3_1 = Variable(B.var_3_1)\n\n    connect(B.par_3_1, A.var_2_1)\n    connect(B.par_4_1, B.var_3_1)\nend\n\nm = Model()\nset_dimension!(m, :time, 2005:2020)\nadd_comp!(m, top, nameof(top))\nupdate_param!(m, :top, :fooA1, 1)\nupdate_param!(m, :top, :fooA2, 2)\nupdate_param!(m, :top, :foo3, 10)\nupdate_param!(m, :top, :foo4, 20)\nupdate_param!(m, :top, :par_1_1, collect(1:length(2005:2020)))\nrun(m)","category":"page"},{"location":"howto/howto_1/#","page":"1 Construct + Run a Model","title":"1 Construct + Run a Model","text":"Take a look at what you've created now using explore(m), a peek into what you can learn in How To Guide 2!","category":"page"},{"location":"explanations/exp_main/#Explanations-Introduction-1","page":"Explanations Intro","title":"Explanations Introduction","text":"","category":"section"},{"location":"explanations/exp_main/#","page":"Explanations Intro","title":"Explanations Intro","text":"The following reference guides are technical descriptions of the Mimi machinery, organized around the actual code behind Mimi and intended to be information-oriented for those interested in the internals or needing to more deeply understand those aspects in order to carry out their projects. Given the complexity of this code base, these references are not comprehensive, but intended to target some important and relevant aspects of Mimi.","category":"page"},{"location":"explanations/exp_main/#","page":"Explanations Intro","title":"Explanations Intro","text":"If you find a bug in these reference guides, or have a clarifying question or suggestion, please reach out via Github Issues or our Mimi Framework forum.  We welcome your feedback.","category":"page"},{"location":"explanations/exp_main/#Available-Reference-Guides-1","page":"Explanations Intro","title":"Available Reference Guides","text":"","category":"section"},{"location":"explanations/exp_main/#","page":"Explanations Intro","title":"Explanations Intro","text":"Explanations: Models as Packages provides a high-level explanation of the practice of organizing models as packages.","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#Advanced-How-to-Guide:-Using-Datum-References-1","page":"Using Datum References","title":"Advanced How-to Guide: Using Datum References","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"While it is not encouraged in the customary use of Mimi, some scenarios may make using references to datum desireable for code brevity and understandability.","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#Component-References-1","page":"Using Datum References","title":"Component References","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"Component references allow you to write cleaner model code when connecting components.  The add_comp! function returns a reference to the component that you just added:","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"using Mimi\n\n# create a component\n@defcomp MyComp begin\n    # empty\nend\n\n# construct a model and add the component\nm = Model()\nset_dimension!(m, :time, collect(2015:5:2110))\nadd_comp!(m, MyComp)\ntypeof(MyComp) # note the type is a Mimi Component Definition","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"If you want to get a reference to a component after the add_comp! call has been made, you can construct the reference as:","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"mycomponent = Mimi.ComponentReference(m, :MyComp)\ntypeof(mycomponent) # note the type is a Mimi Component Reference","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"You can use this component reference in place of the update_param! and connect_param! calls:","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#References-in-place-of-update_param!-1","page":"Using Datum References","title":"References in place of update_param!","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"The line update_param!(model, :MyComponent, :myparameter, myvalue) can be written as mycomponent[:myparameter] = myvalue, where mycomponent is a component reference.","category":"page"},{"location":"howto_advanced/howto_adv_datumrefs/#References-in-place-of-connect_param!-1","page":"Using Datum References","title":"References in place of connect_param!","text":"","category":"section"},{"location":"howto_advanced/howto_adv_datumrefs/#","page":"Using Datum References","title":"Using Datum References","text":"The line connect_param!(model, :MyComponent, :myparameter, :YourComponent, :yourparameter) can be written as mycomponent[:myparameter] = yourcomponent[:yourparameter], where mycomponent and yourcomponent are component references.","category":"page"},{"location":"internals/dimension_mapping/#Cross-model-Connectors-1","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"","category":"section"},{"location":"internals/dimension_mapping/#Thoughts-on-matching-indices-across-models-that-may-have-different-timesteps,-regional-aggregations,-etc.-1","page":"Cross-model Connectors","title":"Thoughts on matching indices across models that may have different timesteps, regional aggregations, etc.","text":"","category":"section"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"The basic idea is to allow a keyword arg to connect_param!() to identify a connector  component that performs the mapping between disparate dimension definitions.","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"We could provide a couple more \"standard\" connectors","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Time\nGet most recent value from before the receiving model's current timestep\nGet the sum of values between the receiving model's current and prior timestep\nRegions\nPass in a region map that defines transformations between two regional definitions\nOperators can include\nWeighted Avg:  new region value = avg(parameter[regions] .* weight[regions])\nWeighted sum: new region value = sum(parameter[regions] .* weight[regions])\nWeights can be the value of some parameter, e.g., population, area, GDP\nDisaggregation can be handled similarly\nnew sub-region value = parameter[region] * weight[region]","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"We can create macro to define connector components that perform these dimension adjustments. We would define a new macro that simplifies creation of a @defcomp of a given name  that can be specified in connect_param! to perform the defined mapping.","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"To map across both time and regions, we could implement a pair of connector components that might look like the following, which would be called for each timestep t in  the receiving component:","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"# This component would run first, mapping emissions to the new time boundaries\n@defcomp time_mapper begin\n    src = Variable(index=[m1.time, m1.regions])\n    dst = Parameter(index=[m2.time, m1.regions])   # uses src model's regions\n\n    # Simple time adapter that just sums any values produced since the prior \n    # timestep, without performing any allocation or interpolation.\n    function run_timestep(p, v, d, t)\n        for r in d.regions\n            values = [v.src[tsrc, r] for tsrc in m1.time if t - 1 < tsrc <= t]\n            p.dst[t, r] = sum(values)\n        end\n    end\nend\n\n# This component would run next, mapping emissions to the new regional boundaries\n@defcomp region_mapper begin\n    # Source here would be the emissions_time_mapper component\n    src  = Variable(index=[time, m1.regions])\n    sgdp = Variable(index=[time, m1.regions])\n    dst  = Parameter(index=[time, m2.regions])\n    dgdp = Parameter(index=[time, m2.regions])\n\n    function run_timestep(p, v, d, t)\n        # Aggregate to region :OthNAmer by summing values of src over :Mex and :Can\n        p.dst[t, :OthNAmer] = sum(v.src[t, [:Mex, :Can]])\n\n        # Disaggregate :SAmer into :Bra and :OthSAmer by fraction of GDP\n        p.dst[:Bra, t]      = v.src[t, :SAmer] * p.dgdp[t, :Bra]      / v.sgdp[t, :SAmer]\n        p.dst[:OthSAmer, t] = v.src[t, :SAmer] * p.dgdp[t, :OthSAmer] / v.sgdp[t, :SAmer]\n    end\nend","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Notes:","category":"page"},{"location":"internals/dimension_mapping/#","page":"Cross-model Connectors","title":"Cross-model Connectors","text":"Specifying index values by symbol as we do currently is inadequate when these can  refer to different models. Probably need to support module specification, e.g.,  dice2010.time.\nWhen combining components with different time dimensions, we should run the model on the union of all time dimension definitions. For example, if model 1 is defined on 10-yr timesteps (2010, 2020, ...) and model 2 is defined on 4-yr timesteps (2010, 2014, 2018, ...), the combined time dimension for the models would be (2010, 2014, 2018, 2020, 2022, ... ).\nThe main run_timestep would iterate over the combined time dimension, calling each component's run_timestep only for timesteps defined for that component.\nIf  src has 5-yr timesteps and dst has 10-yr timesteps, emissions in dst  time tdst would sum emissions from src time tsrc and tsrc - 1.  More generally, accumulating into dst in timestep tdst would sum values from src timesteps tsrc where  tdst - 1 < tsrc <= tdst. For dependencies on the  prior timestep, it would sum values where dst[t-2] < tsrc <= dst[t-1].\nRegional alignment may be combined with timestep alignment. In this case, time should be aligned first, since components are run on time boundaries. Then regional alignment can be handled based on time-aligned values.\nIn some cases, we will want to allocate values from a source model across multiple timesteps in the destination model. For example, if model src is defined on 10-yr timesteps (2010, 2020, 2030, ...) and model dst is defined on 5-yr timesteps, (2010, 2015, 2020, 2025, ...) we might allocate half of the 2010-2010  value from src in 2010-2020 to each of the dst periods 2010-2015 and 2015-2020. This allocation would be appropriate for flow parameters such as emissions. For stock  parameters, e.g., CO<sub>2</sub> concentration, we would want to interpolate between src timestep values.\nThis suggests a need for metadata on parameters indicating whether they are of the stock or flow variety.\nThe problem with this is that is requires knowing a future value to allocate or interpolate between a past value before the dst model's timestep t, and the subsequent value in occurring after t. This would require running the dst model one or more timesteps lagged.","category":"page"},{"location":"#Welcome-to-Mimi-1","page":"Home","title":"Welcome to Mimi","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Mimi is a Julia package that provides a component model for integrated assessment models, as described in detail on the Mimi Framework Homepage.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The documentation is organized into the following four sections, roughly adhering to the Diátaxis documentation framework guidelines. For insights into the goals of each of these documentation categories, please refer to the Diátaxis website.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tutorials\nHow-to Guides\nTechnical Reference\nExplanations","category":"page"},{"location":"#","page":"Home","title":"Home","text":"IMPORTANT: If at any point julia-related issues with workflows, environments, and/or package versioning become frustrating, please do not hesitate to reach out via the forum.  This can be a hurdle to learn at first, but taking a moment to get it right early will save you **a lot of time down the road.  We are more than happy to help you, and are getting together some standardized resources in the meantime.**","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We aim to assist users of all different experience levels, starting with first-time users. If this is your first time using Mimi, we recommend you begin with the Tutorials. In addition, looking through the code at the links below to various existing models based on Mimi can be instructive. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The first step for any user includes installation of julia and Mimi, as well as optionally adding the Mimi Registry. See Tutorial 1: Install Mimi for instructions on these tasks.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"As we work to enhance and improve Mimi we will release new versions of the package. To make sure you always have the latest version of Mimi installed, we recommend that on occasion you run the update command at the julia Pkg REPL. This will update all installed packages to their latest version (not just the Mimi package). To only update the Mimi package you may run the following, although we recommend you do a comprehensive update each time as indicated above. See Tutorial 1: Install Mimi for more!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> update Mimi","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, when in doubt, ask your question on the Mimi Framework forum or post an Issue to the Github repository, the latter being especially pertinent if you have a specific request for the development team.   Don't be shy about either option, we would much prefer to be inundated with lots of questions and help people out than people give up on Mimi!","category":"page"},{"location":"#Models-using-Mimi-1","page":"Home","title":"Models using Mimi","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MimiBRICK.jl\nMimiCIAM.jl\nMimiDICE2010.jl\nMimiDICE2013.jl\nMimiDICE2016.jl (version R not R2)\nMimiDICE2016R2.jl\nMimiFAIR.jl\nMimiFAIR13.jl\nMimiFAIRv1_6_2.jl\nMimiFAIRv2.jl\nMimiFUND.jl\nMimiGIVE.jl\nMimiHECTOR.jl\nMimiIWG.jl\nMimiMAGICC.jl\nMimiMooreEtAlAgricultureImpacts.jl\nMimi_NAS_pH.jl\nmimi_NICE\nMimiPAGE2009.jl\nMimiPAGE2020.jl\nMimiRFFSPs.jl\nMimiRICE2010.jl\nMimi-SNEASY.jl\nMimiSSPs.jl\nAWASH\nPAGE-ICE\nRICE+AIR","category":"page"},{"location":"tutorials/tutorial_1/#Tutorial-1:-Install-Mimi-1","page":"1 Install Mimi","title":"Tutorial 1: Install Mimi","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"This tutorial describes how to set up your system by installing julia, Mimi, and the Mimi registry.","category":"page"},{"location":"tutorials/tutorial_1/#Installing-julia-1","page":"1 Install Mimi","title":"Installing julia","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"Mimi requires the programming language julia to run. You can download the current release from the julia download page. You should download and install the command line version from that page.","category":"page"},{"location":"tutorials/tutorial_1/#Editor-support-1","page":"1 Install Mimi","title":"Editor support","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"There are various editors around that have julia support, including the following:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"IJulia adds julia support to the jupyter (formerly IPython) notebook system.\nVS Code has an excellent julia extension\nother editors such as Emacs and Sublime have julia extensions that add various levels of support for the julia language.","category":"page"},{"location":"tutorials/tutorial_1/#Installing-Mimi-1","page":"1 Install Mimi","title":"Installing Mimi","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"Once julia is installed, start julia and you should see a julia command prompt. Begin an interactive Julia session and enter the Package REPL, which is entered by typing ] and exited with a single backspace:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"julia> ]","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"Next you should run a command that updates your system with the latest information about available packages. It is particularly crucial that you run this command at this point if this is the first time you are using Julia on your system. To run this command, execute the following in the package REPL:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> update","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"Now to install the Mimi package, issue the following command from the Pkg REPL mode:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> add Mimi","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"You only have to run this command once on your machine.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"As we work to enhance and improve Mimi we will release new versions of the package. To make sure you always have the latest version of Mimi installed, we recommend that on occasion you run the update command at the julia Pkg REPL. This will update all installed packages to their latest version (not just the Mimi package). To only update the Mimi package you may run the following, although we recommend you do a comprehensive update each time as indicated above.","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> update Mimi","category":"page"},{"location":"tutorials/tutorial_1/#Using-Mimi-1","page":"1 Install Mimi","title":"Using Mimi","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"When you start a new julia command prompt, Mimi is not yet loaded into that julia session. To load Mimi, issue the following command:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"julia> using Mimi","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"You will have to run this command every time you want to use Mimi in julia. You would typically also add using Mimi to the top of any julia code file that employs the Mimi API.","category":"page"},{"location":"tutorials/tutorial_1/#Mimi-Registry-1","page":"1 Install Mimi","title":"Mimi Registry","text":"","category":"section"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"To access the models in the MimiRegistry, you first need to connect your julia installation with the central Mimi registry of Mimi models. This central registry is like a catalogue of models that use Mimi that is maintained by the Mimi project. For more information about the Mimi Registry see Explanations: Models as Packages, and note that for simplicity we aim to start phasing out use of a Mimi Registry for the General Registry as explained there. To add this registry, run the following command at the julia package REPL:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> registry add https://github.com/mimiframework/MimiRegistry.git","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"You only need to run this command once on a computer. ","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"From there you will be add any of the registered packages, such as MimiDICE2010.jl by running the following command at the julia package REPL:","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"pkg> add MimiDICE2010","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"","category":"page"},{"location":"tutorials/tutorial_1/#","page":"1 Install Mimi","title":"1 Install Mimi","text":"After taking the steps above you have prepared your system and are ready to run the next tutorials!","category":"page"}]
}
